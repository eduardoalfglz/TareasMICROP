
as12, an absolute assembler for Motorola MCU's, version 1.2h

                        ;###################################################################################################################################################################################################
                        ;
                        ;
                        ;               Trabajo Final
                        ;               Eduardo Alfaro Gonzalez
                        ;               B50203
                        ;               Radar 623
                        ;               Ultima vez modificado 28/11/19
                        ;
                        ;
                        ;###################################################################################################################################################################################################
                        #include registers.inc
                        ; Memory maps and register equates
                        ; Choose one of DBUG12MAP (normal operation under DBUG12)
                        ;               EEPROMMAP  (DBUG12 in EEPROM mode)
                        ;               FLASHMAP   (Program loaded into Flash ROM)
0000                    DBUG12MAP equ 0        ; Memory mode is DBUG12MAP
                        ; EEPROMMAP equ 0         ; Memory mode is EEPROMMAP
                        #ifdef DBUG12MAP
0000                    REGBASE        equ        $0        ; register base
1000                    DATASTART equ        $1000        ; Start of data memory
2000                    DATAEND  equ        $2000        ; Stack pointer initial value (end of data RAM area)
2000                    PRSTART equ        $2000        ; Start of program memory (might be ROM)
3bff                    PREND        equ        $3BFF        ; End of program memory
                        
                        ; Functions in D-Bug12
ee84                    Getchar        equ        $EE84        ; Implemented in emulator
ee86                    Putchar equ        $EE86   ; Implemented in emulator
ee88                    Printf  equ     $EE88
ee8a                    GetCmdLine equ  $EE8A   ; FAR call
ee8e                    Sscanhex equ        $EE8E   ; FAR call
ee92                    Isxdigit equ    $EE92
ee94                    Toupper equ     $EE94
ee96                    Isalpha equ     $EE96
ee98                    Strlen  equ     $EE98
ee9a                    Strcpy  equ     $EE9A
ee9c                    Out2hex equ     $EE9C   ; FAR call
eea0                    Out4hex equ     $EEA0   ; FAR call
eea4                    SetUserVector equ $EEA4 ; No longer used
eea6                    WriteEEByte equ $EEA6   ; FAR call
eeaa                    EraseEE equ     $EEAA   ; FAR call
eeae                    ReadMem equ     $EEAE   ; FAR call
eeb2                    WriteMem equ    $EEB2   ; FAR call
                        
3e00                    VECTORTABLE equ $3E00        ; Vectors go here SHOULD ALSO INITIALIZE AT RUNTIME
0000                    STATICVECTORS equ 0        ; Define vectors statically (in "ROM")
0000                    INITIALIZEVECTORS equ 0        ; Initialize vectors at runtime
                        #endif
                        
                        #ifdef EEPROMMAP
                        REGBASE        equ        $0        ; register base MAY BE MOVED TO MAKE FULL EEPROM ACCESSABLE
                        DATASTART equ        $1000        ; Start of data memory
                        DATAEND  equ        $3E00        ; Stack pointer initial value (end of data RAM area)
                        PRSTART equ        $400        ; Start of program memory
                        PREND        equ        $FFF        ; End of program memory
                        
                        VECTORTABLE equ $3E00        ; Vectors go here -- MUST BE INITIALIZED AT RUNTIME
                        INITIALIZEVECTORS equ 0        ; Initialize vectors at runtime
                        #endif
                        
                        #ifdef FLASHMAP
                        REGBASE        equ        $0        ; register base MAY BE MOVED TO MAKE FULL EEPROM ACCESSABLE
                        DATASTART equ        $1000        ; Start of data memory
                        DATAEND  equ        $4000        ; Stack pointer initial value (end of data RAM area)
                        PRSTART equ        $8000        ; Start of program memory
                        ; Note -- there are problems using the current free assemblers with paged memory
                        ; Best bet is to use logical addresses $8000 up only, set page register to 3E,
                        ; Change S1 records for $8000-BFFF to S2 records for page 3E and S1 records for $C000-$EFFF to
                        ; page 3F. Program startup vector goes in EFFE, and needs to be iin page 3F so PPAGE can be changed. 
                        PREND        equ        $EF7F        ; End of program memory
                        
                        VECTORTABLE equ $EF80        ; Vectors go here -- MUST BE INITIALIZED STATICALLY
                        STATICVECTORS equ 0        ; Define vectors statically (in "ROM")
                        #endif
                        
                        
1000                    RAMSTART equ        DATASTART ; For compatibility
2000                    RAMEND equ        DATAEND   
                        
3e00                    UserRsrv0x80 equ (0*2)+VECTORTABLE
3e02                    UserRsrv0x82 equ (1*2)+VECTORTABLE
3e04                    UserRsrv0x84 equ (2*2)+VECTORTABLE
3e06                    UserRsrv0x86 equ (3*2)+VECTORTABLE
3e08                    UserRsrv0x88 equ (4*2)+VECTORTABLE
3e0a                    UserRsrv0x8a equ (5*2)+VECTORTABLE
3e0c                    UserPWMShDn equ (6*2)+VECTORTABLE
3e0e                    UserPortP equ (7*2)+VECTORTABLE
3e10                    UserMSCAN4Tx equ (8*2)+VECTORTABLE
3e12                    UserMSCAN4Rx equ (9*2)+VECTORTABLE
3e14                    UserMSCAN4Errs equ (10*2)+VECTORTABLE
3e16                    UserMSCAN4Wake equ (11*2)+VECTORTABLE
3e18                    UserMSCAN3Tx equ (12*2)+VECTORTABLE
3e1a                    UserMSCAN3Rx equ (13*2)+VECTORTABLE
3e1c                    UserMSCAN3Errs equ (14*2)+VECTORTABLE
3e1e                    UserMSCAN3Wake equ (15*2)+VECTORTABLE
3e20                    UserMSCAN2Tx equ (16*2)+VECTORTABLE
3e22                    UserMSCAN2Rx equ (17*2)+VECTORTABLE
3e24                    UserMSCAN2Errs equ (18*2)+VECTORTABLE
3e26                    UserMSCAN2Wake equ (19*2)+VECTORTABLE
3e28                    UserMSCAN1Tx equ (20*2)+VECTORTABLE
3e2a                    UserMSCAN1Rx equ (21*2)+VECTORTABLE
3e2c                    UserMSCAN1Errs equ (22*2)+VECTORTABLE
3e2e                    UserMSCAN1Wake equ (23*2)+VECTORTABLE
3e30                    UserMSCAN0Tx equ (24*2)+VECTORTABLE
3e32                    UserMSCAN0Rx equ (25*2)+VECTORTABLE
3e34                    UserMSCAN0Errs equ (26*2)+VECTORTABLE
3e36                    UserMSCAN0Wake equ (27*2)+VECTORTABLE
3e38                    UserFlash equ (28*2)+VECTORTABLE
3e3a                    UserEEPROM equ (29*2)+VECTORTABLE
3e3c                    UserSPI2 equ (30*2)+VECTORTABLE
3e3e                    UserSPI1 equ (31*2)+VECTORTABLE
3e40                    UserIIC equ (32*2)+VECTORTABLE
3e42                    UserDLC equ (33*2)+VECTORTABLE
3e44                    UserSCME equ (34*2)+VECTORTABLE
3e46                    UserCRG equ (35*2)+VECTORTABLE
3e48                    UserPAccBOv equ (36*2)+VECTORTABLE
3e4a                    UserModDwnCtr equ (37*2)+VECTORTABLE
3e4c                    UserPortH equ (38*2)+VECTORTABLE
3e4e                    UserPortJ equ (39*2)+VECTORTABLE
3e50                    UserAtoD1 equ (40*2)+VECTORTABLE
3e52                    UserAtoD0 equ (41*2)+VECTORTABLE
3e54                    UserSCI1 equ (42*2)+VECTORTABLE
3e56                    UserSCI0 equ (43*2)+VECTORTABLE
3e58                    UserSPI0 equ (44*2)+VECTORTABLE
3e5a                    UserPAccEdge equ (45*2)+VECTORTABLE
3e5c                    UserPAccOvf equ (46*2)+VECTORTABLE
3e5e                    UserTimerOvf equ (47*2)+VECTORTABLE
3e60                    UserTimerCh7 equ (48*2)+VECTORTABLE
3e62                    UserTimerCh6 equ (49*2)+VECTORTABLE
3e64                    UserTimerCh5 equ (50*2)+VECTORTABLE
3e66                    UserTimerCh4 equ (51*2)+VECTORTABLE
3e68                    UserTimerCh3 equ (52*2)+VECTORTABLE
3e6a                    UserTimerCh2 equ (53*2)+VECTORTABLE
3e6c                    UserTimerCh1 equ (54*2)+VECTORTABLE
3e6e                    UserTimerCh0 equ (55*2)+VECTORTABLE
3e70                    UserRTI equ (56*2)+VECTORTABLE
3e72                    UserIRQ equ (57*2)+VECTORTABLE
3e74                    UserXIRQ equ (58*2)+VECTORTABLE
3e76                    UserSWI equ (59*2)+VECTORTABLE
3e78                    UserTrap equ (60*2)+VECTORTABLE
                        
                        
                        *
                        *
                        *  HC12 i/o register locations (9s12dp256)
                        *
                        *
0000                    PORTA:          equ REGBASE+0   ;port a = address lines a8 - a15
0001                    PORTB:          equ REGBASE+1   ;port b = address lines a0 - a7
0002                    DDRA:           equ REGBASE+2   ;port a direction register
0003                    DDRB:           equ REGBASE+3   ;port b direction register
                        
0008                    PORTE:          equ REGBASE+8   ;port e = mode,irq and control signals
0009                    DDRE:           equ REGBASE+9   ;port e direction register
000a                    PEAR:           equ REGBASE+$a  ;port e assignments
000b                    MODE:           equ REGBASE+$b  ;mode register
000c                    PUCR:           equ REGBASE+$c  ;port pull-up control register
000d                    RDRIV:          equ REGBASE+$d  ;port reduced drive control register
000e                    EBICTL:                equ REGBASE+$e  ;e stretch control
                        
0010                    INITRM:         equ REGBASE+$10 ;ram location register
0011                    INITRG:         equ REGBASE+$11 ;register location register
0012                    INITEE:         equ REGBASE+$12 ;eeprom location register
0013                    MISC:           equ REGBASE+$13 ;miscellaneous mapping control
0014                    MTST0:          equ REGBASE+$14 ; reserved
0015                    ITCR:           equ REGBASE+$15 ;interrupt test control register
0016                    ITEST:          equ REGBASE+$16 ;interrupt test register
0017                    MTST1:          equ REGBASE+$17 ; reserved
                        
001a                    PARTIDH:        equ REGBASE+$1a ;part id high
001b                    PARTIDL:        equ REGBASE+$1b ;part id low
001c                    MEMSIZ0:        equ REGBASE+$1c ;memory size
001d                    MEMSIZ1:        equ REGBASE+$1d ;memory size
001e                    IRQCR:          equ REGBASE+$1e ;interrupt control register
001e                    INTCR:          equ REGBASE+$1e ;interrupt control register (old name)
001f                    HPRIO:          equ REGBASE+$1f ;high priority reg
                        
0028                    BKPCT0:         equ REGBASE+$28 ;break control register
0029                    BKPCT1:         equ REGBASE+$29 ;break control register
002a                    BKP0X:          equ REGBASE+$2a ; break 0 index register
002b                    BKP0H:          equ REGBASE+$2b ; break 0 pointer high
002c                    BRP0L:          equ REGBASE+$2c ; break 0 pointer low
002d                    BKP1X:          equ REGBASE+$2d ; break 1 index register
002e                    BKP1H:          equ REGBASE+$2e ; break 1 pointer high
002f                    BRP1L:          equ REGBASE+$2f ; break 1 pointer low
0030                    PPAGE:                equ REGBASE+$30 ;program page register
                        
0032                    PORTK:                equ REGBASE+$32 ;port k data
0033                    DDRK:                equ REGBASE+$33 ;port k direction
                        
0034                    SYNR:           equ REGBASE+$34 ; synthesizer / multiplier register
0035                    REFDV:          equ REGBASE+$35 ; reference divider register
0036                    CTFLG:          equ REGBASE+$36 ; reserved
0037                    CRGFLG:         equ REGBASE+$37 ; pll flags register
0038                    CRGINT:         equ REGBASE+$38 ; pll interrupt register
0039                    CLKSEL:         equ REGBASE+$39 ; clock select register
003a                    PLLCTL:         equ REGBASE+$3a ; pll control register
003b                    RTICTL:         equ REGBASE+$3b ;real time interrupt control
003c                    COPCTL:         equ REGBASE+$3c ;watchdog control
003d                    FORBYP:         equ REGBASE+$3d ;
003e                    CTCTL:          equ REGBASE+$3e ;
003f                    ARMCOP:         equ REGBASE+$3f ;cop reset register
                        
0040                    TIOS:           equ REGBASE+$40 ;timer input/output select
0041                    CFORC:          equ REGBASE+$41 ;timer compare force
0042                    OC7M:           equ REGBASE+$42 ;timer output compare 7 mask
0043                    OC7D:           equ REGBASE+$43 ;timer output compare 7 data
0044                    TCNT:           equ REGBASE+$44 ;timer counter register hi
                        *TCNT:          equ REGBASE+$45 ;timer counter register lo
0046                    TSCR:           equ REGBASE+$46 ;timer system control register (Old Name)
0046                    TSCR1:          equ REGBASE+$46 ;timer system control register
0047                    TTOV:           equ REGBASE+$47 ;reserved
0048                    TCTL1:          equ REGBASE+$48 ;timer control register 1
0049                    TCTL2:          equ REGBASE+$49 ;timer control register 2
004a                    TCTL3:          equ REGBASE+$4a ;timer control register 3
004b                    TCTL4:          equ REGBASE+$4b ;timer control register 4
004c                    TMSK1:          equ REGBASE+$4c ;timer interrupt mask 1 (Old Name)
004c                    TIE:            equ REGBASE+$4c ;timer interrupt mask 1
004d                    TMSK2:          equ REGBASE+$4d ;timer interrupt mask 2 (Old Name)
004d                    TSCR2:          equ REGBASE+$4d ;timer interrupt mask 2
004e                    TFLG1:          equ REGBASE+$4e ;timer flags 1
004f                    TFLG2:          equ REGBASE+$4f ;timer flags 2
0050                    TC0:            equ REGBASE+$50 ;timer capture/compare register 0
0052                    TC1:            equ REGBASE+$52 ;timer capture/compare register 1
0054                    TC2:            equ REGBASE+$54 ;timer capture/compare register 2
0056                    TC3:            equ REGBASE+$56 ;timer capture/compare register 3
0058                    TC4:            equ REGBASE+$58 ;timer capture/compare register 4
005a                    TC5:            equ REGBASE+$5a ;timer capture/compare register 5
005c                    TC6:            equ REGBASE+$5c ;timer capture/compare register 6
005e                    TC7:            equ REGBASE+$5e ;timer capture/compare register 7
0060                    PACTL:          equ REGBASE+$60 ;pulse accumulator controls
0061                    PAFLG:          equ REGBASE+$61 ;pulse accumulator flags
0062                    PACN3:          equ REGBASE+$62 ;pulse accumulator counter 3
0063                    PACN2:          equ REGBASE+$63 ;pulse accumulator counter 2
0064                    PACN1:          equ REGBASE+$64 ;pulse accumulator counter 1
0065                    PACN0:          equ REGBASE+$65 ;pulse accumulator counter 0
0066                    MCCTL:          equ REGBASE+$66 ;modulus down conunter control
0067                    MCFLG:          equ REGBASE+$67 ;down counter flags
0068                    ICPAR:          equ REGBASE+$68 ;input pulse accumulator control
0069                    DLYCT:          equ REGBASE+$69 ;delay count to down counter
006a                    ICOVW:          equ REGBASE+$6a ;input control overwrite register
006b                    ICSYS:          equ REGBASE+$6b ;input control system control
                        
006d                    TIMTST:         equ REGBASE+$6d ;timer test register
                        
0070                    PBCTL:          equ REGBASE+$70 ; pulse accumulator b control
0071                    PBFLG:          equ REGBASE+$71 ; pulse accumulator b flags
0072                    PA3H:           equ REGBASE+$72 ; pulse accumulator holding register 3
0073                    PA2H:           equ REGBASE+$73 ; pulse accumulator holding register 2
0074                    PA1H:           equ REGBASE+$74 ; pulse accumulator holding register 1
0075                    PA0H:           equ REGBASE+$75 ; pulse accumulator holding register 0
0076                    MCCNT:          equ REGBASE+$76 ; modulus down counter register
                        *MCCNTL:        equ REGBASE+$77 ; low byte
0078                    TCOH:           equ REGBASE+$78 ; capture 0 holding register
007a                    TC1H:           equ REGBASE+$7a ; capture 1 holding register
007c                    TC2H:           equ REGBASE+$7c ; capture 2 holding register
007e                    TC3H:           equ REGBASE+$7e ; capture 3 holding register
                        
0080                    ATD0CTL0:       equ REGBASE+$80 ;adc control 0 (reserved)
0081                    ATD0CTL1:       equ REGBASE+$81 ;adc control 1 (reserved)
0082                    ATD0CTL2:       equ REGBASE+$82 ;adc control 2
0083                    ATD0CTL3:       equ REGBASE+$83 ;adc control 3
0084                    ATD0CTL4:       equ REGBASE+$84 ;adc control 4
0085                    ATD0CTL5:       equ REGBASE+$85 ;adc control 5
0086                    ATD0STAT:       equ REGBASE+$86 ;adc status register hi
0086                    ATD0STAT0:      equ REGBASE+$86 ;adc status register hi
008b                    ATD0STAT1:      equ REGBASE+$8b ;adc status register lo
0088                    ATD0TEST:       equ REGBASE+$88 ;adc test (reserved)
                        *atd0test       equ REGBASE+$89 ;
                        
008d                    ATD0DIEN:        equ REGBASE+$8d ;
                        
008f                    PORTAD:         equ REGBASE+$8f ;port adc = input only
0090                    ADR00H:         equ REGBASE+$90 ;adc result 0 register
0092                    ADR01H:         equ REGBASE+$92 ;adc result 1 register
0094                    ADR02H:         equ REGBASE+$94 ;adc result 2 register
0096                    ADR03H:         equ REGBASE+$96 ;adc result 3 register
0098                    ADR04H:         equ REGBASE+$98 ;adc result 4 register
009a                    ADR05H:         equ REGBASE+$9a ;adc result 5 register
009c                    ADR06H:         equ REGBASE+$9c ;adc result 6 register
009e                    ADR07H:         equ REGBASE+$9e ;adc result 7 register
                        
00a0                    PWME:                equ REGBASE+$a0 ;pwm enable
00a1                    PWMPOL:         equ REGBASE+$a1 ;pwm polarity
00a2                    PWMCLK:         equ REGBASE+$a2 ;pwm clock select register
00a3                    PWMPRCLK:       equ REGBASE+$a3 ;pwm prescale clock select register
00a4                    PWMCAE:         equ REGBASE+$a4 ;pwm center align select register
00a5                    PWMCTL:         equ REGBASE+$a5 ;pwm control register
00a6                    PWMTST:         equ REGBASE+$a6 ;reserved
00a7                    PWMPRSC:        equ REGBASE+$a7 ;reserved
00a8                    PWMSCLA:        equ REGBASE+$a8 ;pwm scale a
00a9                    PWMSCLB:        equ REGBASE+$a9 ;pwm scale b
00aa                    PWMSCNTA:       equ REGBASE+$aa ;reserved
00ab                    PWMSCNTB:       equ REGBASE+$ab ;reserved
00ac                    PWMCNT0:        equ REGBASE+$ac ;pwm channel 0 counter
00ad                    PWMCNT1:        equ REGBASE+$ad ;pwm channel 1 counter
00ae                    PWMCNT2:        equ REGBASE+$ae ;pwm channel 2 counter
00af                    PWMCNT3:        equ REGBASE+$af ;pwm channel 3 counter
00b0                    PWMCNT4:        equ REGBASE+$b0 ;pwm channel 4 counter
00b1                    PWMCNT5:        equ REGBASE+$b1 ;pwm channel 5 counter
00b2                    PWMCNT6:        equ REGBASE+$b2 ;pwm channel 6 counter
00b3                    PWMCNT7:        equ REGBASE+$b3 ;pwm channel 7 counter
00b4                    PWMPER0:        equ REGBASE+$b4 ;pwm channel 0 period
00b5                    PWMPER1:        equ REGBASE+$b5 ;pwm channel 1 period
00b6                    PWMPER2:        equ REGBASE+$b6 ;pwm channel 2 period
00b7                    PWMPER3:        equ REGBASE+$b7 ;pwm channel 3 period
00b8                    PWMPER4:        equ REGBASE+$b8 ;pwm channel 4 period
00b9                    PWMPER5:        equ REGBASE+$b9 ;pwm channel 5 period
00ba                    PWMPER6:        equ REGBASE+$ba ;pwm channel 6 period
00bb                    PWMPER7:        equ REGBASE+$bb ;pwm channel 7 period
00bc                    PWMDTY0:        equ REGBASE+$bc ;pwm channel 0 duty cycle
00bd                    PWMDTY1:        equ REGBASE+$bd ;pwm channel 1 duty cycle
00be                    PWMDTY2:        equ REGBASE+$be ;pwm channel 2 duty cycle
00bf                    PWMDTY3:        equ REGBASE+$bf ;pwm channel 3 duty cycle
00c0                    PWMDTY4:        equ REGBASE+$c0 ;pwm channel 4 duty cycle
00c1                    PWMDTY5:        equ REGBASE+$c1 ;pwm channel 5 duty cycle
00c2                    PWMDTY6:        equ REGBASE+$c2 ;pwm channel 6 duty cycle
00c3                    PWMDTY7:        equ REGBASE+$c3 ;pwm channel 7 duty cycle
00c4                    PWMSDN:         equ REGBASE+$c4 ;pwm shutdown register
                        
00c8                    SC0BDH:         equ REGBASE+$c8 ;sci 0 baud reg hi byte
00c9                    SC0BDL:         equ REGBASE+$c9 ;sci 0 baud reg lo byte
00ca                    SC0CR1:         equ REGBASE+$ca ;sci 0 control1 reg
00cb                    SC0CR2:         equ REGBASE+$cb ;sci 0 control2 reg
00cc                    SC0SR1:         equ REGBASE+$cc ;sci 0 status reg 1
00cd                    SC0SR2:         equ REGBASE+$cd ;sci 0 status reg 2
00ce                    SC0DRH:         equ REGBASE+$ce ;sci 0 data reg hi
00cf                    SC0DRL:         equ REGBASE+$cf ;sci 0 data reg lo
                        
00d0                    SC1BDH:         equ REGBASE+$d0 ;sci 1 baud reg hi byte
00d1                    SC1BDL:         equ REGBASE+$d1 ;sci 1 baud reg lo byte
00d2                    SC1CR1:         equ REGBASE+$d2 ;sci 1 control1 reg
00d3                    SC1CR2:         equ REGBASE+$d3 ;sci 1 control2 reg
00d4                    SC1SR1:         equ REGBASE+$d4 ;sci 1 status reg 1
00d5                    SC1SR2:         equ REGBASE+$d5 ;sci 1 status reg 2
00d6                    SC1DRH:         equ REGBASE+$d6 ;sci 1 data reg hi
00d7                    SC1DRL:         equ REGBASE+$d7 ;sci 1 data reg lo
                        
00d8                    SPI0CR1:        equ REGBASE+$d8 ;spi 0 control1 reg
00d9                    SPI0CR2:        equ REGBASE+$d9 ;spi 0 control2 reg
00da                    SPI0BR:         equ REGBASE+$da ;spi 0 baud reg
00db                    SPI0SR:         equ REGBASE+$db ;spi 0 status reg hi
00dd                    SP0DR:          equ REGBASE+$dd ;spi 0 data reg  FOR COMPATIBILITY
00dd                    SPI0DR:          equ REGBASE+$dd ;spi 0 data reg
                        
00e0                    IBAD:                equ REGBASE+$e0 ;i2c bus address register
00e1                    IBFD:                equ REGBASE+$e1 ;i2c bus frequency divider
00e2                    IBCR:                equ REGBASE+$e2 ;i2c bus control register
00e3                    IBSR:                equ REGBASE+$e3 ;i2c bus status register
00e4                    IBDR:                equ REGBASE+$e4 ;i2c bus message data register
                        
00e8                    DLCBCR1:        equ REGBASE+$e8 ;bdlc control regsiter 1
00e9                    DLCBSVR:        equ REGBASE+$e9 ;bdlc state vector register
00ea                    DLCBCR2:        equ REGBASE+$ea ;bdlc control register 2
00eb                    DLCBDR:                equ REGBASE+$eb ;bdlc data register
00ec                    DLCBARD:        equ REGBASE+$ec ;bdlc analog delay register
00ed                    DLCBRSR:        equ REGBASE+$ed ;bdlc rate select register
00ee                    DLCSCR:                equ REGBASE+$ee ;bdlc control register
00ef                    DLCBSTAT:        equ REGBASE+$ef ;bdlc status register
                        
00f0                    SPI1CR1:        equ REGBASE+$f0 ;spi 1 control1 reg
00f1                    SPI1CR2:        equ REGBASE+$f1 ;spi 1 control2 reg
00f2                    SPI1BR:         equ REGBASE+$f2 ;spi 1 baud reg
00f3                    SPI1SR:         equ REGBASE+$f3 ;spi 1 status reg hi
00f5                    SPI1DR:          equ REGBASE+$f5 ;spi 1 data reg
00f5                    SP1DR:          equ REGBASE+$f5 ;spi 1 data reg   FOR COMPATIBILITY
                        
00f8                    SPI2CR1:        equ REGBASE+$f8 ;spi 2 control1 reg
00f9                    SPI2CR2:        equ REGBASE+$f9 ;spi 2 control2 reg
00fa                    SPI2BR:         equ REGBASE+$fa ;spi 2 baud reg
00fb                    SPI2SR:         equ REGBASE+$fb ;spi 2 status reg hi
00fd                    SPI2DR:         equ REGBASE+$fd ;spi 2 data reg
00fd                    SP2DR:          equ REGBASE+$fd ;spi 2 data reg   FOR COMPATIBILITY
                        
0100                    FCLKDIV:        equ REGBASE+$100 ;flash clock divider
0101                    FSEC:                equ REGBASE+$101 ;flash security register
                        
0103                    FCNFG:                equ REGBASE+$103 ;flash configuration register
0104                    FPROT:                equ REGBASE+$104 ;flash protection register
0105                    FSTAT:                equ REGBASE+$105 ;flash status register
0106                    FCMD:                equ REGBASE+$106 ;flash command register
                        
0110                    ECLKDIV:        equ REGBASE+$110 ;eeprom clock divider
                        
0113                    ECNFG:                equ REGBASE+$113 ;eeprom configuration register
0114                    EPROT:                equ REGBASE+$114 ;eeprom protection register
0115                    ESTAT:                equ REGBASE+$115 ;eeprom status register
0116                    ECMD:                equ REGBASE+$116 ;eeprom command register
                        
0120                    ATD1CTL0:       equ REGBASE+$120 ;adc1 control 0 (reserved)
0121                    ATD1CTL1:       equ REGBASE+$121 ;adc1 control 1 (reserved)
0122                    ATD1CTL2:       equ REGBASE+$122 ;adc1 control 2
0123                    ATD1CTL3:       equ REGBASE+$123 ;adc1 control 3
0124                    ATD1CTL4:       equ REGBASE+$124 ;adc1 control 4
0125                    ATD1CTL5:       equ REGBASE+$125 ;adc1 control 5
0126                    ATD1STAT0:      equ REGBASE+$126 ;adc1 status register hi
012b                    ATD1STAT1:      equ REGBASE+$12b ;adc1 status register lo
0128                    ATD1TEST:       equ REGBASE+$128 ;adc1 test (reserved)
                        *atd1test       equ REGBASE+$129 ;
                        
012d                    ATDDIEN:        equ REGBASE+$12d ;adc1 input enable register
                        
012f                    PORTAD1:        equ REGBASE+$12f ;port adc1 = input only
0130                    ADR10H:         equ REGBASE+$130 ;adc1 result 0 register
0132                    ADR11H:         equ REGBASE+$132 ;adc1 result 1 register
0134                    ADR12H:         equ REGBASE+$134 ;adc1 result 2 register
0136                    ADR13H:         equ REGBASE+$136 ;adc1 result 3 register
0138                    ADR14H:         equ REGBASE+$138 ;adc1 result 4 register
013a                    ADR15H:         equ REGBASE+$13a ;adc1 result 5 register
013c                    ADR16H:         equ REGBASE+$13c ;adc1 result 6 register
013e                    ADR17H:         equ REGBASE+$13e ;adc1 result 7 register
                        
0140                    CAN0CTL0:        equ REGBASE+$140 ;can0 control register 0
0141                    CAN0CTL1:        equ REGBASE+$141 ;can0 control register 1
0142                    CAN0BTR0:        equ REGBASE+$142 ;can0 bus timing register 0
0143                    CAN0BTR1:        equ REGBASE+$143 ;can0 bus timing register 1
0144                    CAN0RFLG:        equ REGBASE+$144 ;can0 receiver flags
0145                    CAN0RIER:        equ REGBASE+$145 ;can0 receiver interrupt enables
0146                    CAN0TFLG:        equ REGBASE+$146 ;can0 transmit flags
0147                    CAN0TIER:        equ REGBASE+$147 ;can0 transmit interrupt enables
0148                    CAN0TARQ:        equ REGBASE+$148 ;can0 transmit message abort control
0149                    CAN0TAAK:        equ REGBASE+$149 ;can0 transmit message abort status
014a                    CAN0TBEL:        equ REGBASE+$14a ;can0 transmit buffer select
014b                    CAN0IDAC:        equ REGBASE+$14b ;can0 identfier acceptance control
                        
014e                    CAN0RERR:        equ REGBASE+$14e ;can0 receive error counter
014f                    CAN0TERR:        equ REGBASE+$14f ;can0 transmit error counter
0150                    CAN0IDA0:        equ REGBASE+$150 ;can0 identifier acceptance register 0
0151                    CAN0IDA1:        equ REGBASE+$151 ;can0 identifier acceptance register 1
0152                    CAN0IDA2:        equ REGBASE+$152 ;can0 identifier acceptance register 2
0153                    CAN0IDA3:        equ REGBASE+$153 ;can0 identifier acceptance register 3
0154                    CAN0IDM0:        equ REGBASE+$154 ;can0 identifier mask register 0
0155                    CAN0IDM1:        equ REGBASE+$155 ;can0 identifier mask register 1
0156                    CAN0IDM2:        equ REGBASE+$156 ;can0 identifier mask register 2
0157                    CAN0IDM3:        equ REGBASE+$157 ;can0 identifier mask register 3
0158                    CAN0IDA4:        equ REGBASE+$158 ;can0 identifier acceptance register 4
0159                    CAN0IDA5:        equ REGBASE+$159 ;can0 identifier acceptance register 5
015a                    CAN0IDA6:        equ REGBASE+$15a ;can0 identifier acceptance register 6
015b                    CAN0IDA7:        equ REGBASE+$15b ;can0 identifier acceptance register 7
015c                    CAN0IDM4:        equ REGBASE+$15c ;can0 identifier mask register 4
015d                    CAN0IDM5:        equ REGBASE+$15d ;can0 identifier mask register 5
015e                    CAN0IDM6:        equ REGBASE+$15e ;can0 identifier mask register 6
015f                    CAN0IDM7:        equ REGBASE+$15f ;can0 identifier mask register 7
0160                    CAN0RXFG:        equ REGBASE+$160 ;can0 rx foreground buffer thru +$16f
0170                    CAN0TXFG:        equ REGBASE+$170 ;can0 tx foreground buffer thru +$17f
                        
0180                    CAN1CTL0:        equ REGBASE+$180 ;can1 control register 0
0181                    CAN1CTL1:        equ REGBASE+$181 ;can1 control register 1
0182                    CAN1BTR0:        equ REGBASE+$182 ;can1 bus timing register 0
0183                    CAN1BTR1:        equ REGBASE+$183 ;can1 bus timing register 1
0184                    CAN1RFLG:        equ REGBASE+$184 ;can1 receiver flags
0185                    CAN1RIER:        equ REGBASE+$185 ;can1 receiver interrupt enables
0186                    CAN1TFLG:        equ REGBASE+$186 ;can1 transmit flags
0187                    CAN1TIER:        equ REGBASE+$187 ;can1 transmit interrupt enables
0188                    CAN1TARQ:        equ REGBASE+$188 ;can1 transmit message abort control
0189                    CAN1TAAK:        equ REGBASE+$189 ;can1 transmit message abort status
018a                    CAN1TBEL:        equ REGBASE+$18a ;can1 transmit buffer select
018b                    CAN1IDAC:        equ REGBASE+$18b ;can1 identfier acceptance control
                        
018e                    CAN1RERR:        equ REGBASE+$18e ;can1 receive error counter
018f                    CAN1TERR:        equ REGBASE+$18f ;can1 transmit error counter
0190                    CAN1IDA0:        equ REGBASE+$190 ;can1 identifier acceptance register 0
0191                    CAN1IDA1:        equ REGBASE+$191 ;can1 identifier acceptance register 1
0192                    CAN1IDA2:        equ REGBASE+$192 ;can1 identifier acceptance register 2
0193                    CAN1IDA3:        equ REGBASE+$193 ;can1 identifier acceptance register 3
0194                    CAN1IDM0:        equ REGBASE+$194 ;can1 identifier mask register 0
0195                    CAN1IDM1:        equ REGBASE+$195 ;can1 identifier mask register 1
0196                    CAN1IDM2:        equ REGBASE+$196 ;can1 identifier mask register 2
0197                    CAN1IDM3:        equ REGBASE+$197 ;can1 identifier mask register 3
0198                    CAN1IDA4:        equ REGBASE+$198 ;can1 identifier acceptance register 4
0199                    CAN1IDA5:        equ REGBASE+$199 ;can1 identifier acceptance register 5
019a                    CAN1IDA6:        equ REGBASE+$19a ;can1 identifier acceptance register 6
019b                    CAN1IDA7:        equ REGBASE+$19b ;can1 identifier acceptance register 7
019c                    CAN1IDM4:        equ REGBASE+$19c ;can1 identifier mask register 4
019d                    CAN1IDM5:        equ REGBASE+$19d ;can1 identifier mask register 5
019e                    CAN1IDM6:        equ REGBASE+$19e ;can1 identifier mask register 6
019f                    CAN1IDM7:        equ REGBASE+$19f ;can1 identifier mask register 7
01a0                    CAN1RXFG:        equ REGBASE+$1a0 ;can1 rx foreground buffer thru +$1af
01b0                    CAN1TXFG:        equ REGBASE+$1b0 ;can1 tx foreground buffer thru +$1bf
                        
01c0                    CAN2CTL0:        equ REGBASE+$1c0 ;can2 control register 0
01c1                    CAN2CTL1:        equ REGBASE+$1c1 ;can2 control register 1
01c2                    CAN2BTR0:        equ REGBASE+$1c2 ;can2 bus timing register 0
01c3                    CAN2BTR1:        equ REGBASE+$1c3 ;can2 bus timing register 1
01c4                    CAN2RFLG:        equ REGBASE+$1c4 ;can2 receiver flags
01c5                    CAN2RIER:        equ REGBASE+$1c5 ;can2 receiver interrupt enables
01c6                    CAN2TFLG:        equ REGBASE+$1c6 ;can2 transmit flags
01c7                    CAN2TIER:        equ REGBASE+$1c7 ;can2 transmit interrupt enables
01c8                    CAN2TARQ:        equ REGBASE+$1c8 ;can2 transmit message abort control
01c9                    CAN2TAAK:        equ REGBASE+$1c9 ;can2 transmit message abort status
01ca                    CAN2TBEL:        equ REGBASE+$1ca ;can2 transmit buffer select
01cb                    CAN2IDAC:        equ REGBASE+$1cb ;can2 identfier acceptance control
                        
01ce                    CAN2RERR:        equ REGBASE+$1ce ;can2 receive error counter
01cf                    CAN2TERR:        equ REGBASE+$1cf ;can2 transmit error counter
01d0                    CAN2IDA0:        equ REGBASE+$1d0 ;can2 identifier acceptance register 0
01d1                    CAN2IDA1:        equ REGBASE+$1d1 ;can2 identifier acceptance register 1
01d2                    CAN2IDA2:        equ REGBASE+$1d2 ;can2 identifier acceptance register 2
01d3                    CAN2IDA3:        equ REGBASE+$1d3 ;can2 identifier acceptance register 3
01d4                    CAN2IDM0:        equ REGBASE+$1d4 ;can2 identifier mask register 0
01d5                    CAN2IDM1:        equ REGBASE+$1d5 ;can2 identifier mask register 1
01d6                    CAN2IDM2:        equ REGBASE+$1d6 ;can2 identifier mask register 2
01d7                    CAN2IDM3:        equ REGBASE+$1d7 ;can2 identifier mask register 3
01d8                    CAN2IDA4:        equ REGBASE+$1d8 ;can2 identifier acceptance register 4
01d9                    CAN2IDA5:        equ REGBASE+$1d9 ;can2 identifier acceptance register 5
01da                    CAN2IDA6:        equ REGBASE+$1da ;can2 identifier acceptance register 6
01db                    CAN2IDA7:        equ REGBASE+$1db ;can2 identifier acceptance register 7
01dc                    CAN2IDM4:        equ REGBASE+$1dc ;can2 identifier mask register 4
01dd                    CAN2IDM5:        equ REGBASE+$1dd ;can2 identifier mask register 5
01de                    CAN2IDM6:        equ REGBASE+$1de ;can2 identifier mask register 6
01df                    CAN2IDM7:        equ REGBASE+$1df ;can2 identifier mask register 7
01e0                    CAN2RXFG:        equ REGBASE+$1e0 ;can2 rx foreground buffer thru +$1ef
01f0                    CAN2TXFG:        equ REGBASE+$1f0 ;can2 tx foreground buffer thru +$1ff
                        
0200                    CAN3CTL0:        equ REGBASE+$200 ;can3 control register 0
0201                    CAN3CTL1:        equ REGBASE+$201 ;can3 control register 1
0202                    CAN3BTR0:        equ REGBASE+$202 ;can3 bus timing register 0
0203                    CAN3BTR1:        equ REGBASE+$203 ;can3 bus timing register 1
0204                    CAN3RFLG:        equ REGBASE+$204 ;can3 receiver flags
0205                    CAN3RIER:        equ REGBASE+$205 ;can3 receiver interrupt enables
0206                    CAN3TFLG:        equ REGBASE+$206 ;can3 transmit flags
0207                    CAN3TIER:        equ REGBASE+$207 ;can3 transmit interrupt enables
0208                    CAN3TARQ:        equ REGBASE+$208 ;can3 transmit message abort control
0209                    CAN3TAAK:        equ REGBASE+$209 ;can3 transmit message abort status
020a                    CAN3TBEL:        equ REGBASE+$20a ;can3 transmit buffer select
020b                    CAN3IDAC:        equ REGBASE+$20b ;can3 identfier acceptance control
                        
020e                    CAN3RERR:        equ REGBASE+$20e ;can3 receive error counter
020f                    CAN3TERR:        equ REGBASE+$20f ;can3 transmit error counter
0210                    CAN3IDA0:        equ REGBASE+$210 ;can3 identifier acceptance register 0
0211                    CAN3IDA1:        equ REGBASE+$211 ;can3 identifier acceptance register 1
0212                    CAN3IDA2:        equ REGBASE+$212 ;can3 identifier acceptance register 2
0213                    CAN3IDA3:        equ REGBASE+$213 ;can3 identifier acceptance register 3
0214                    CAN3IDM0:        equ REGBASE+$214 ;can3 identifier mask register 0
0215                    CAN3IDM1:        equ REGBASE+$215 ;can3 identifier mask register 1
0216                    CAN3IDM2:        equ REGBASE+$216 ;can3 identifier mask register 2
0217                    CAN3IDM3:        equ REGBASE+$217 ;can3 identifier mask register 3
0218                    CAN3IDA4:        equ REGBASE+$218 ;can3 identifier acceptance register 4
0219                    CAN3IDA5:        equ REGBASE+$219 ;can3 identifier acceptance register 5
021a                    CAN3IDA6:        equ REGBASE+$21a ;can3 identifier acceptance register 6
021b                    CAN3IDA7:        equ REGBASE+$21b ;can3 identifier acceptance register 7
021c                    CAN3IDM4:        equ REGBASE+$21c ;can3 identifier mask register 4
021d                    CAN3IDM5:        equ REGBASE+$21d ;can3 identifier mask register 5
021e                    CAN3IDM6:        equ REGBASE+$21e ;can3 identifier mask register 6
021f                    CAN3IDM7:        equ REGBASE+$21f ;can3 identifier mask register 7
0220                    CAN3RXFG:        equ REGBASE+$220 ;can3 rx foreground buffer thru +$22f
0230                    CAN3TXFG:        equ REGBASE+$230 ;can3 tx foreground buffer thru +$23f
                        
0240                    PTT:                equ REGBASE+$240 ;portt data register
0241                    PTIT:                equ REGBASE+$241 ;portt input register
0242                    DDRT:                equ REGBASE+$242 ;portt direction register
0243                    RDRT:                equ REGBASE+$243 ;portt reduced drive register
0244                    PERT:                equ REGBASE+$244 ;portt pull device enable
0245                    PPST:                equ REGBASE+$245 ;portt pull polarity select
                        
0248                    PTS:                equ REGBASE+$248 ;ports data register
0249                    PTIS:                equ REGBASE+$249 ;ports input register
024a                    DDRS:                equ REGBASE+$24a ;ports direction register
024b                    RDRS:                equ REGBASE+$24b ;ports reduced drive register
024c                    PERS:                equ REGBASE+$24c ;ports pull device enable
024d                    PPSS:                equ REGBASE+$24d ;ports pull polarity select
024e                    WOMS:                equ REGBASE+$24e ;ports wired or mode register
                        
0250                    PTM:                equ REGBASE+$250 ;portm data register
0251                    PTIM:                equ REGBASE+$251 ;portm input register
0252                    DDRM:                equ REGBASE+$252 ;portm direction register
0253                    RDRM:                equ REGBASE+$253 ;portm reduced drive register
0254                    PERM:                equ REGBASE+$254 ;portm pull device enable
0255                    PPSM:                equ REGBASE+$255 ;portm pull polarity select
0256                    WOMM:                equ REGBASE+$256 ;portm wired or mode register
0257                    MODRR:                equ REGBASE+$257 ;portm module routing register
                        
0258                    PTP:                equ REGBASE+$258 ;portp data register
0259                    PTIP:                equ REGBASE+$259 ;portp input register
025a                    DDRP:                equ REGBASE+$25a ;portp direction register
025b                    RDRP:                equ REGBASE+$25b ;portp reduced drive register
025c                    PERP:                equ REGBASE+$25c ;portp pull device enable
025d                    PPSP:                equ REGBASE+$25d ;portp pull polarity select
025e                    PIEP:                equ REGBASE+$25e ;portp interrupt enable register
025f                    PIFP:                equ REGBASE+$25f ;portp interrupt flag register
                        
0260                    PTH:                equ REGBASE+$260 ;porth data register
0261                    PTIH:                equ REGBASE+$261 ;porth input register
0262                    DDRH:                equ REGBASE+$262 ;porth direction register
0263                    RDRH:                equ REGBASE+$263 ;porth reduced drive register
0264                    PERH:                equ REGBASE+$264 ;porth pull device enable
0265                    PPSH:                equ REGBASE+$265 ;porth pull polarity select
0266                    PIEH:                equ REGBASE+$266 ;porth interrupt enable register
0267                    PIFH:                equ REGBASE+$267 ;porth interrupt flag register
                        
0268                    PTJ:                equ REGBASE+$268 ;portj data register
0269                    PTIJ:                equ REGBASE+$269 ;portj input register
026a                    DDRJ:                equ REGBASE+$26a ;portj direction register
026b                    RDRJ:                equ REGBASE+$26b ;portj reduced drive register
026c                    PERJ:                equ REGBASE+$26c ;portj pull device enable
026d                    PPSJ:                equ REGBASE+$26d ;portj pull polarity select
026e                    PIEJ:                equ REGBASE+$26e ;portj interrupt enable register
026f                    PIFJ:                equ REGBASE+$26f ;portj interrupt flag register
                        
0280                    CAN4CTL0:        equ REGBASE+$280 ;can4 control register 0
0281                    CAN4CTL1:        equ REGBASE+$281 ;can4 control register 1
0282                    CAN4BTR0:        equ REGBASE+$282 ;can4 bus timing register 0
0283                    CAN4BTR1:        equ REGBASE+$283 ;can4 bus timing register 1
0284                    CAN4RFLG:        equ REGBASE+$284 ;can4 receiver flags
0285                    CAN4RIER:        equ REGBASE+$285 ;can4 receiver interrupt enables
0286                    CAN4TFLG:        equ REGBASE+$286 ;can4 transmit flags
0287                    CAN4TIER:        equ REGBASE+$287 ;can4 transmit interrupt enables
0288                    CAN4TARQ:        equ REGBASE+$288 ;can4 transmit message abort control
0289                    CAN4TAAK:        equ REGBASE+$289 ;can4 transmit message abort status
028a                    CAN4TBEL:        equ REGBASE+$28a ;can4 transmit buffer select
028b                    CAN4IDAC:        equ REGBASE+$28b ;can4 identfier acceptance control
                        
028e                    CAN4RERR:        equ REGBASE+$28e ;can4 receive error counter
028f                    CAN4TERR:        equ REGBASE+$28f ;can4 transmit error counter
0290                    CAN4IDA0:        equ REGBASE+$290 ;can4 identifier acceptance register 0
0291                    CAN4IDA1:        equ REGBASE+$291 ;can4 identifier acceptance register 1
0292                    CAN4IDA2:        equ REGBASE+$292 ;can4 identifier acceptance register 2
0293                    CAN4IDA3:        equ REGBASE+$293 ;can4 identifier acceptance register 3
0294                    CAN4IDM0:        equ REGBASE+$294 ;can4 identifier mask register 0
0295                    CAN4IDM1:        equ REGBASE+$295 ;can4 identifier mask register 1
0296                    CAN4IDM2:        equ REGBASE+$296 ;can4 identifier mask register 2
0297                    CAN4IDM3:        equ REGBASE+$297 ;can4 identifier mask register 3
0298                    CAN4IDA4:        equ REGBASE+$298 ;can4 identifier acceptance register 4
0299                    CAN4IDA5:        equ REGBASE+$299 ;can4 identifier acceptance register 5
029a                    CAN4IDA6:        equ REGBASE+$29a ;can4 identifier acceptance register 6
029b                    CAN4IDA7:        equ REGBASE+$29b ;can4 identifier acceptance register 7
029c                    CAN4IDM4:        equ REGBASE+$29c ;can4 identifier mask register 4
029d                    CAN4IDM5:        equ REGBASE+$29d ;can4 identifier mask register 5
029e                    CAN4IDM6:        equ REGBASE+$29e ;can4 identifier mask register 6
029f                    CAN4IDM7:        equ REGBASE+$29f ;can4 identifier mask register 7
02a0                    CAN4RXFG:        equ REGBASE+$2a0 ;can4 rx foreground buffer thru +$2af
02b0                    CAN4TXFG:        equ REGBASE+$2b0 ;can4 tx foreground buffer thru +$2bf
                        
                        * end registers
                        #endinclude

                        ;###################################################################################################################################################################################################
                        ;Descripcion General:
                        ;El siguiente código para la tarjeta dragon 12 de FreeScale corresponde a un sensor de velocidad para vehiculos,
                        ;este cuenta con 3 modos, el primero es utilizado para configurar la velocidad limite de la zona, esto se hace 
                        ;por medio del uso del teclado matricial de la tarjeta y los displays de 7 segmentos para mostrar la velocidad
                        ;configurada, el segundo modo corresponde a un modo libre donde el sensor no realiza ninguna operacion, finalmente
                        ;el ultimo modo corresponde a la medicion de velocidades la cual se realiza por medio de los botones del puerto H
                        ;una vez que se determina la velocidad se muestra en pantalla si es un valor valido y si se pasa de la velocidad 
                        ;limite configurada se enciende una alarma representada en los leds. Cada modo cuenta con sus respectivos mensajes
                        ;en la pantlla LCD.
                        
                        
                        ;###################################################################################################################################################################################################
                        
                        
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;               Definicion de estructuras de datos
                        
                        
                        
000d                    CR:             equ $0D
000a                    LF:             equ $0A
0000                    FIN:            equ $0
                        
1000                                    org $1000
1000                    BANDERAS:      ds 2    ;7: MOD_H      6:MOD_L  3:Enable tick_vel  2:PRINT Calculando... 1:Data or Control LCD    0:Cambio_Modo
                            ;0: TCL_Lista   1:TCL_Leida     2:ARRAY_OK  3:PANT_FLAG     4:ALERTA        5:CALC_TICK
1002                    V_LIM:          ds 1    ;Velocidad limite
1003 02                 MAX_TCL:        db 2    ;Maximo numero de teclas que se aceptan del teclado matricial, en este caso 2
1004                    TECLA:          ds 1    ;Tecla ingresada
1005                    TECLA_IN:       ds 1    ;Tecla anterior
                        
1006                    CONT_REB:       ds 1    ;Contador de rebotes, utilizado para suprimirlos
1007                    CONT_TCL:       ds 1    ;
1008                    PATRON:         ds 1    ;Patron a enviar para leer las teclas del teclado
                                
                        
1009                    NUM_ARRAY:      ds 2
100b                    BRILLO:         ds 1        ; 0-100 cotrola el brillo de 7 seg
100c                    POT:            ds 1        ;Variable que almacena el valor promedio del ATD
100d                    TICK_EN:        ds 2        ;Cantidad de ticks necesarios para cubrir 100m
100f                    TICK_DIS:       ds 2        ;Cantidad de ticks necesarios para cubrir 200m
1011                    VELOC:          ds 1        ;VELOCIDAD MEDIDA POR LOS SENSORES
1012                    TICK_VEL:       ds 1        ;Ticks utilizados para sensar la velocidad del vehiculo    
                        
                        
1013                    BIN1:           ds 1        ;corresponde al valor de DISP1 y DISP2 en binario
1014                    BIN2:           ds 1        ;corresponde al valor de DISP4 y DISP3 en binario
                        
1015                    BCD1:           ds 1        ;bin 1 en bcd
1016                    BCD2:           ds 1        ;bin 2 en bcd
1017                    BCD_L:          ds 1
1018                    LOW:            ds 1        ;ni idea
                        
                        
1019                    DISP1:          ds 1        ;izquierda bcd1
101a                    DISP2:          ds 1        ;derecha bcd1
101b                    DISP3:          ds 1        ;izquierda bcd 2
101c                    DISP4:          ds 1        ;derecha bcd2  
                        
101d                    LEDS:           ds 1        ;valor que se envia al puerto B para los leds
                        
101e                    CONT_DIG:       ds 1        ;digito actual de 7seg
101f                    CONT_TICKS:     ds 1        ;
                        
1020                    DT:             ds 1        ;100 - BRILLO, valor donde se resetea CONT_TICKS
                        
                        
1021                    CONT_7SEG:      ds 2        ;cuando llega a 5000 se actualizan los valores de DISP
1023                    CONT_200        ds 2        ;contador para 200 ms para habilitar el atd, se cambia a word por el tamaño de lo que almacena
1025                    CONT_DELAY:     ds 1        ;
1026 64                 D2mS:           db 100      ;Constante para generar un delay de 2 ms
1027 0d                 D240uS:         db 13       ;Constante para generar un delay de 260 ms
1028 03                 D60uS:          db 3        ;Constante para generar un delay de 60 ms
                        
1029 01                 Clear_LCD:      db $01      ;constante igual a comando clear
102a 80                 ADD_L1:         db $80      ;constante igual a Adress linea 1 lcd
102b c0                 ADD_L2:         db $C0      ;constante igual a Adress linea 2 lcd
102c                    TEMP:           ds 1
102d                    LEDS37:         ds 1        ;Variable que define el desplazamiento de los leds 3:7 en modo alerta
102e                    Variable2:      ds 1
102f                    Variable3:      ds 1
                        
                        
                        
                        
1030                                    org $1030
1030 01 04 07 02 05 08  TECLAS:         db $01,$04,$07,$02,$05,$08,$03,$06,$09,$0B,$00,$0E
     03 06 09 0b 00 0e
                        
                        
                        
                         
1040                                    org $1040
1040 3f 06 5b 4f 66 6d  SEGMENT:        db $3F,$06,$5B,$4F,$66,$6D,$7D,$07,$7F,$6F,$40,$00  ;0,1,2,3,4,5,6,7,8,9,-,Apagar
     7d 07 7f 6f 40 00
                                        
                                        
                                        
1050                                    org $1050
                        
                        
1050 04 28 28 06 0c     iniDsp:         db 04,$28,$28,$06,$0C     ;numero de bytes,function set, function set, entry mode, display on off
                        
1060                                    org $1060
1060 20 20 4d 4f 44 4f  MESS1:          fcc "  MODO CONFIG"
     20 43 4f 4e 46 49
     47
106d 00                                 db FIN
106e 20 56 45 4c 4f 43  MESS2:          fcc " VELOC. LIMITE"
     2e 20 4c 49 4d 49
     54 45
107c 00                                 db FIN
107d 20 20 52 41 44 41  MESS3:          fcc "  RADAR   623"
     52 20 20 20 36 32
     33
108a 00                                 db FIN
108b 20 20 20 4d 4f 44  MESS4:          fcc "   MODO LIBRE"
     4f 20 4c 49 42 52
     45
1098 00                                 db FIN
1099 20 4d 4f 44 4f 20  MESS5:          fcc " MODO MEDICION"
     4d 45 44 49 43 49
     4f 4e
10a7 00                                 db FIN
10a8 53 55 20 56 45 4c  MESS6:          fcc "SU VEL. VEL.LIM"
     2e 20 56 45 4c 2e
     4c 49 4d
10b7 00                                 db FIN
10b8 20 20 45 53 50 45  MESS7:          fcc "  ESPERANDO..."
     52 41 4e 44 4f 2e
     2e 2e
10c6 00                                 db FIN            
10c7 20 20 43 41 4c 43  MESS8:          fcc "  CALCULANDO..."
     55 4c 41 4e 44 4f
     2e 2e 2e
10d6 00                                 db FIN                
                        
                        
                        
                        
                        
                                        
                        ;Subrutinas de interrupcion                
3e70                                    org $3E70
3e70 22 26                              dw RTI_ISR
3e4c                                    org $3E4C
3e4c 21 a8                              dw PTH_ISR
3e66                                    org $3E66
3e66 22 32                              dw OC4_ISR
3e52                                    org $3E52
3e52 22 fb                              dw ATD_ISR
3e5e                                    org $3E5E
3e5e 23 25                              dw TCNT_ISR
                        
                        ;################################################
                        ;       Programa principal
2000                                    org $2000
                        
                        
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;       Definicion de hardware
                        
                        ;       LEDS
2000 18 0b ff 00 03                     movb #$FF, DDRB
2005 1c 02 6a 02                        bset DDRJ,$02
2009 1c 02 68 02                        bset PTJ, $02
                        
                        ;       7SEG
200d 18 0b 0f 02 5a                     movb #$0F, DDRP
2012 18 0b 0f 02 58                     movb #$0F, PTP
                        ;       Output compare
2017 18 0b 80 00 46                     movb #$80, TSCR1        ;Habilita el modulo sin tffca
201c 18 0b 03 00 4d                     movb #$03, TSCR2        ;Prescaler de 8
2021 18 0b 10 00 40                     movb #$10, TIOS         ;Habilita la salida del oc4
2026 18 0b 00 00 48                     movb #$00, TCTL1        ;Salida de oc4 en toggle
202b 79 00 49                           clr TCTL2
202e 18 0b ff 00 4f                     movb #$FF,TFLG2 ; 
2033 18 0b ff 00 4e                     movb #$FF,TFLG1 ;                
2038 18 0b 10 00 4c                     movb #$10, TIE          ;Habilita la interrupcion de oc4
203d dc 44                              ldd TCNT
203f c3 00 3c                           addd #60
2042 5c 58                              std TC4
                                        
2044 18 0b ff 00 33                     movb #$FF,DDRK          ;Utilizado en pantala LCD
                        
                        
                        ;       ATD0
2049 18 0b c2 00 82                     movb #$C2, ATD0CTL2
204e c6 c8                              ldab #200
2050 04 31 fd           loopIATD:       dbne B,loopIATD         ;loop de retardo para encender el convertidor
2053 18 0b 30 00 83                     movb #$30, ATD0CTL3     ;6 mediciones
2058 18 0b b7 00 84                     movb #$B7, ATD0CTL4     ;8 bits, 4 ciclos de atd, PRS $17
205d 18 0b 87 00 85                     movb #$87, ATD0CTL5     
                        ;       Puerto H sw
                        
                        ;               bset PIEH, $0C          ;habilitar interrupciones PH
2062 1c 02 67 0f                        bset PIFH, $0F
                        ;       RTI                 
2066 18 0b 17 00 3b                     movb #$17, RTICTL       ; esto lo pone en 1.024 ms
206b 4c 38 80                           bset CRGINT, $80        ;habilitar interrupciones rti
                        ;       Puerto A teclado                
206e 18 0b f0 00 02                     movb #$F0, DDRA
2073 4c 0c 01                           bset PUCR, $01          ;Super importante habilitar resistencia de pullup
                        ;                bclr RDRIV, $01
                        
2076 10 ef                              cli
                        
                        
                        
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        
                        ;               inicializacion
2078 cf 3b ff                           lds #$3BFF
207b 79 10 15                           clr BCD1        ;Se borra el contenido de las varibles de la pantalla de 7 seg
207e 79 10 16                           clr BCD2
2081 79 10 14                           clr BIN2
2084 79 10 13                           clr BIN1
2087 18 0b 02 10 1d                     movb #02,LEDS
208c 18 0b 80 10 2d                     movb #$80,LEDS37
2091 79 10 19                           clr DISP1
2094 79 10 1a                           clr DISP2
2097 79 10 1b                           clr DISP3
209a 79 10 1c                           clr DISP4
209d 79 10 11                           clr VELOC
                                        ;modser=1
20a0 18 0b 01 10 1e                     movb #1,CONT_DIG
20a5 79 10 1f                           clr CONT_TICKS
20a8 18 0b 32 10 0b                     movb #50, BRILLO        ;El brillo se inicializa en la mitad, luego se le asigna el valor del atd
20ad 18 0b 00 10 02                     movb #00, V_LIM
                                        
                        
20b2 18 0b ff 10 04                     movb #$FF, TECLA
20b7 18 0b ff 10 05                     movb #$FF, TECLA_IN
20bc 79 10 07                           clr CONT_TCL
20bf 79 10 06                           clr CONT_REB
20c2 1d 10 01 ff                        bclr (BANDERAS+1),$FF      ;Poner las banderas de teclados en 0 
20c6 1c 10 00 01                        bset BANDERAS,$01      ;Poner la bandera cambio nodo en 1 y el resto no importan
20ca 1d 10 00 c4                        bclr BANDERAS,$C4      ;modo en 00 es decir MODO config, se borra la bandera print Calculando                
20ce b6 10 03                           ldaa MAX_TCL
20d1 ce 10 08                           ldx #NUM_ARRAY-1
20d4 18 08 e4 ff        LoopCLR:        movb #$FF,A,X          ;iniciar el arreglo en FF
20d8 04 30 f9                           dbne A,LoopCLR
                        
                        
                        ;       Programa main   
                        ;################################################################################################################################################
                        ;Descripcion:   
                        ;       Es el programa principal del codigo es el encargado de detectar por medio de los dipswitch
                        ;       cual modo ha sido selecionado y mostrar en pantalla el mensaje correspondiente.
                        
                        
                        ;Paso de parametros:
                        ;Entrada:
                            ;V_LIM: Velocidad limite, si es 0 no puede cambiar de modo
                            ;MESS1 
                            ;MESS2
                            ;MESS3
                            ;MESS4
                            ;MESS5
                            ;MESS7
                        ;Salida:
                            ;LEDS: Se enciende dependiendo del modo
                            ;BIN1: Dependiendo del modo se resetea a $BB
                            ;BIN2: Dependiendo del modo se resetea a $BB
                        ;################################################################################################################################################
                        mainL:          loc
20db f7 10 02                           tst V_LIM               ;La velocidad debe ser distanta de cero para salir de modo configs
20de 27 37                              beq chkModoLC           ;Salta a revisar si es modo config o libre
20e0 b6 02 61                           ldaa PTIH               ;se cargan los valores de los dipswitch
20e3 84 c0                              anda #$C0               ;Se utilizan solo los bits de modo
20e5 f6 10 00                           ldab BANDERAS          ;Bits de banderas que corresponden a modos
20e8 c4 c0                              andb #$C0               ;Bits de modo
20ea 18 17                              cba
20ec 27 24                              beq nochange`
20ee 81 40                              cmpa #$40               ;se revisa que el modo no sea el valor invalido
20f0 27 20                              beq nochange`                
20f2 1c 10 00 01                        bset BANDERAS,$01      ;Se activa cambio de modo
20f6 81 80                              cmpa #$80               ;Revisar si es modo libre
20f8 27 0a                              beq swML`
20fa 81 c0                              cmpa #$C0
20fc 27 10                              beq swMM`
20fe 1d 10 00 c0                        bclr BANDERAS,$C0      ;Si los switches estan en modo config se configura en el registro MOD
2102 20 0e                              bra nochange`
2104 1c 10 00 80        swML`           bset BANDERAS,$80      ;Si los switches estan en modo libre se configura en el registro MOD
2108 1d 10 00 40                        bclr BANDERAS,$40
210c 20 04                              bra nochange`
210e 1c 10 00 c0        swMM`           bset BANDERAS,$C0      ;Si los switches estan en modo medicion se configura en el registro MOD
                        
2112 1e 10 00 c0 5d     nochange`       brset BANDERAS,$C0,chkModoM`
                        
                                        
                                        
2117 79 10 11           chkModoLC:      clr VELOC
211a 1d 02 66 09                        bclr PIEH,$09                       ;Se deshabilitan las interrupciones del puerto H, TOI y se pone veloc en 0
211e 1c 02 67 09                        bset PIFH,$09
2122 18 0b 03 00 4d                     movb #$03,TSCR2
2127 1d 10 01 18                        bclr (BANDERAS+1),$18                  ;FIXME:Se borra la bandera de alerta y la bandera de PANT_FLAG
212b 1f 10 00 c0 1c                     brclr BANDERAS,$C0,chkModoC`       ;Salta a revisar el modo Config
                        
                        
2130 1f 10 00 01 12     chkModoL`       brclr BANDERAS,$01,jmodolibre`           ;Tecnicamente aqui deberia saltar a modo libre, pero no hace nada
2135 1d 10 00 01                        bclr BANDERAS,$01                  
2139 18 0b 04 10 1d                     movb #$04,LEDS                                
213e ce 10 7d                           ldx #MESS3
2141 cd 10 8b                           ldy #MESS4
2144 16 24 75                           jsr CARGAR_LCD                
2147 16 26 47           jmodolibre`     jsr MODO_LIBRE
214a 20 8f                              bra mainL
                        
214c 1f 10 00 01 1d     chkModoC`       brclr BANDERAS,$01,jmodoconfig`
2151 1d 10 00 01                        bclr BANDERAS,$01                                  
2155 18 0c 10 02 10 13                  movb V_LIM,BIN1             ;Si esta en modo config se revisa si hay cambio de modo para imprimir en la LCD
215b 18 0b bb 10 14                     movb #$BB,BIN2               ;88 para pruebas
2160 ce 10 60                           ldx #MESS1
2163 cd 10 6e                           ldy #MESS2
2166 18 0b 01 10 1d                     movb #$01,LEDS
216b 16 24 75                           jsr CARGAR_LCD
                                        
                        
216e 16 25 f9           jmodoconfig`    jsr MODO_CONFIG
2171 06 20 db                           jmp mainL
                        
2174 1f 10 00 01 24     chkModoM`       brclr BANDERAS,$01,jmodormedicion`
2179 1c 02 66 09                        bset PIEH,$09               ;La primera vez que se llega a este modo se habilitan las interrupciones del puerto H
217d 1c 02 67 09                        bset PIFH,$09                
2181 1d 10 00 01                        bclr BANDERAS,$01
2185 18 0b 02 10 1d                     movb #$02,LEDS
218a 18 0b bb 10 13                     movb #$BB,BIN1
218f 18 0b bb 10 14                     movb #$BB,BIN2              ;Se borra la pantalla de 7 seg
2194 ce 10 99                           ldx #MESS5
2197 cd 10 b8                           ldy #MESS7
219a 16 24 75                           jsr CARGAR_LCD
219d 18 0b 83 00 4d     jmodormedicion` movb #$83,TSCR2
21a2 16 26 26                           jsr MODO_MEDICION
21a5 06 20 db                           jmp mainL
                        
                        
                        
                                        
                                        
                        ;################################################################################################################################################################################################
                        ;       Subrutinas
                        
                        
                        
                        
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;################################################################################################################################################################################################
                        ;       Subrutinas de interrupciones
                        
                        ;       Subrutinas PH
                        
                        
                                        loc
21a8 1e 02 67 01 0f     PTH_ISR:        brset PIFH,$01,PH0_ISR          ;Se revisa cual interrupcion es 1 y 2 estan siempre deshabilitadas
21ad 1e 02 67 02 4e                     brset PIFH,$02,PH1_ISR
21b2 1e 02 67 04 4e                     brset PIFH,$04,PH2_ISR
21b7 1e 02 67 08 4f                     brset PIFH,$08,PH3_ISR
                        
                        ;       subrutina PH0
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Simula el segundo sensor, aparte de eso incluye la subrutina calculo, es decir a partir de la cantidad de 
                        ;       Ticks calcula la velocidad del vehiculo así como la los ticks necesarios para mostrar la velocidad y los 
                        ;       necesarios para borrarla de pantalla
                        
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       TICK_VEL: ticks que tarda el vehiculo en recorrer 40 m
                        ;       CONT_REB: contador de rebotes
                        
                        
                        ;Salida:
                        
                        ;       VELOC: Velocidad del vehiculo
                        ;       TICK_EN: Ticks para habilitar el mensaje en pantalla y velocidad en 7 seg
                        ;       TICK_DIS: Ticks para deshabilitar el mensaje en pantalla y borrar velocidad en 7 seg      
                        ;################################################################################################################################################
21bc                    PH0_ISR:        ;bset PORTB,$04
21bc 1c 02 67 01                        bset PIFH, $01 
21c0 f7 10 06                           tst CONT_REB
21c3 26 3f                              bne returnPH 
21c5 18 0b 64 10 06                     movb #100,CONT_REB          ;Si el contador de rebotes es distinto de 0 se ejecuta el Calculo
21ca f6 10 12                           ldab TICK_VEL            ;Se revisa que tick_Vel sea diferente de cero         
21cd 27 35                              beq returnPH
21cf 1d 10 00 08                        bclr BANDERAS,$08      
21d3 c1 1a                              cmpb #26                ;26 es el numero minimo de ticks si es menor el resultado de la velocidad es mayor a 255 y se desborda           
21d5 24 07                              bhs validSpeed`         ;Comparacion sin signo
21d7 18 0b ff 10 11                     movb #$FF,VELOC
21dc 20 10                              bra SetTicks`
21de 86 00              validSpeed`     ldaa #0                 ;Se carga en D TICK_VEL, ya que en X no se puede porque es un byte
21e0 ce 66 ff                           ldx #26367               
21e3 b7 c5                              xgdx                 ;Se intercambian para la division
21e5 18 10                              idiv
21e7 b7 54                              tfr X,D                 ;Se vuelven a intercambiar para guardar el resultado en veloc que es un byte
21e9 49                                 lsrd
21ea 49                                 lsrd
21eb 7b 10 11                           stab VELOC              ;Se procede a calcular los ticks para las banderas
21ee f6 10 12           SetTicks`       ldab TICK_VEL           ;Se multiplica tick_vel por 5 para obtener la cantidad de ticks para 200 m
21f1 86 05                              ldaa #5
21f3 12                                 mul
21f4 79 10 12                           clr TICK_VEL
21f7 7c 10 0f                           std TICK_DIS
21fa 49                                 lsrd
21fb 7c 10 0d                           std TICK_EN             ;Se divide entre 2 para obtener la cantidad de ticks para 100 m                                                        
21fe 20 04                              bra returnPH
                        
                        ;       subrutina PH1
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Esta subrutina nunca se utiliza
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;Salida:
                        ;################################################################################################################################################
2200 1c 02 67 02        PH1_ISR:        bset PIFH, $02                                          
2204 0b                 returnPH:       rti
                        ;       subrutina PH2
                        ;################################################################################################################################################
                        ;Descripcion: 
                        ;       Esta subrutina nunca se utiliza        
                        
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;Salida:
                        ;################################################################################################################################################                
2205 1c 02 67 04        PH2_ISR:        bset PIFH, $04 
                                                     
2209 20 f9                              bra returnPH
                        ;       subrutina PH3
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Sensor 1 inicia el conteo de ticks
                        
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       CONT_REB
                        ;Salida:
                        ;       TICK_VEL: se borran en esta interrupcion
                        ;################################################################################################################################################
220b 1c 02 67 08        PH3_ISR:        bset PIFH, $08
220f f7 10 06                           tst CONT_REB
2212 26 f0                              bne returnPH                
2214 18 0b 64 10 06                     movb #100,CONT_REB
2219 79 10 12                           clr TICK_VEL
221c 1c 10 00 04                        bset BANDERAS,$04          ;Se levanta la bandera de print Calculando 
2220 1c 10 00 08                        bset BANDERAS,$08          ;Se levanta la bandera que habilita el conteo de ticks
2224 20 de                              bra returnPH                
                        
                        
                        
                        ;       subrutina de rti
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;      Subrutina encarga del manejo de los rebotes de los botones     
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;      CONT_REB: se debe verificar que no sea 0
                        ;Salida:
                        ;      CONT_REB: si no es cero se decrementa
                        ;################################################################################################################################################
                                        loc
2226 4c 37 80           RTI_ISR:        bset CRGFLG, $80
2229 f7 10 06                           tst CONT_REB            ;Es subrutina solo se usa para el contador de rebotes 
222c 27 03                              beq return`
222e 73 10 06                           dec CONT_REB
2231 0b                 return`         rti
                        
                        
                        ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                        ;   Subrutina OC4       
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Subrutina encargada del manejo de la pantalla de 7 segmentos, maneja el contenido de los displays y como se multiplexan
                        ;       ademas cada cierto tiempo debe llamar al convertidor analogico digital y el control de los leds en el modo alarma, tambien
                        ;       llama a la subrutina bcd 7 segmnetos
                        
                        
                        ;Paso de parametros:
                        ;Entrada:
                                ;DT: determina si se debe apagar la pantalla actual determinado por atd
                                ;DISP1,DISP2,DISP3,DISP4: Contenido que se debe mostrar en los 
                                ;LEDS:Variable que determina el patron de los leds
                        ;Salida:
                                ;CONT_DELAY: contador de retraso para contador de pantalla de 7 segmentos
                        ;################################################################################################################################################
                                        loc
2232 dc 44              OC4_ISR:        ldd TCNT
2234 c3 00 3c                           addd #60
2237 5c 58                              std TC4
2239 18 0b ff 00 4e                     movb #$FF,TFLG1         ;Se hace borrado manual para evitar conflictos con TCNT
223e f7 10 25                           tst CONT_DELAY          ;Segunda parte de OC4, encargada de manejar cont_delay, cont_200 y la subrutina bcd_7seg
2241 27 03                              beq tst7seg`
2243 73 10 25                           dec CONT_DELAY
2246 fe 10 21           tst7seg`        ldx CONT_7SEG           ;cuando el contador de 7seg es 0 se debe llamar a la subrutina y configurar el contador en 5000
2249 27 06                              beq JBCD_7SEG`
224b 09                                 dex
224c 7e 10 21                           stx CONT_7SEG
224f 20 0c                              bra tst200`
2251 18 03 13 88 10 21  JBCD_7SEG`      movw #5000,CONT_7SEG
2257 16 24 4f                           jsr BCD_7SEG  
225a 16 25 48                           jsr CONV_BIN_BCD              
225d fe 10 23           tst200`         ldx CONT_200
2260 27 06                              beq enableATDLEDs`
2262 09                                 dex
2263 7e 10 23                           stx CONT_200
2266 20 0e                              bra part2` 
                        
2268 18 03 27 10 10 23  enableATDLEDs`  movw #10000,CONT_200         ;Reseteo de contador
226e 18 0b 87 00 85                     movb #$87, ATD0CTL5         ;Convertidor atd
2273 16 26 d2                           jsr PATRON_LEDS             ;Leds de alarma
                                  
                                       
                        
                        ;               Aqui comienza el manejo de la pantalla        
2276 b6 10 1f           part2`          ldaa CONT_TICKS
2279 f6 10 20                           ldab DT
                        
227c 18 17                              cba
227e 2c 0e                              bge apagar`         ; Si n ticks son iguales al DT se apaga la pantalla
2280 f7 10 1f                           tst CONT_TICKS
2283 27 27                              beq check_digit`
2285 81 64              checkN`         cmpa #100           ;Si es 100 se debe encender un digito
2287 27 13                              beq changeDigit`
2289 72 10 1f           incticks`       inc CONT_TICKS
228c 20 6c                              bra returnOC4`
                        ;Apagar
228e 18 0b ff 02 58     apagar`         movb #$FF,PTP
2293 1d 02 68 02                        bclr PTJ, $02
2297 79 00 01                           clr PORTB
229a 20 e9                              bra checkN`
                        ;           cambiar digito
229c 79 10 1f           changeDigit`    clr CONT_TICKS            ;Reset de contador
229f 72 10 1e                           inc CONT_DIG
22a2 86 05                              ldaa #5
22a4 b1 10 1e                           cmpa CONT_DIG
22a7 26 51                              bne returnOC4`                 
22a9 79 10 1e                           clr CONT_DIG                    ;Reset del contador de digito
                        ;           encender digito
22ac b6 10 1e           check_digit`    ldaa CONT_DIG               ;Se verifica cual digito se debe configurar 
                        
22af ce 10 19                           ldx #DISP1
22b2 18 0d e4 00 01                     movb A,X,PORTB                  ;Direcciona el valor por direccionamiento indexado
22b7 1c 02 68 02                        bset PTJ, $02
22bb 81 00                              cmpa #0
22bd 26 0a                              bne dig2`                
22bf 18 0b 07 02 58                     movb #$07,PTP
22c4 72 10 1f           ndig1`          inc CONT_TICKS
22c7 20 31                              bra returnOC4`
22c9 81 01              dig2`           cmpa #1                     ;Se repite el mismo proceso para los otros digitos
22cb 26 0a                              bne dig3`
22cd 18 0b 0b 02 58                     movb #$0B,PTP                                
22d2 72 10 1f           ndig2`          inc CONT_TICKS
22d5 20 23                              bra returnOC4`
22d7 81 02              dig3`           cmpa #2
22d9 26 0a                              bne dig4`                
22db 18 0b 0d 02 58                     movb #$0D,PTP                                                
22e0 72 10 1f           ndig3`          inc CONT_TICKS
22e3 20 15                              bra returnOC4`
22e5 81 03              dig4`           cmpa #3
22e7 26 0a                              bne digleds`                                          
22e9 18 0b 0e 02 58                     movb #$0E,PTP  
22ee 72 10 1f           ndig4`          inc CONT_TICKS
22f1 20 07                              bra returnOC4`
22f3 1d 02 68 02        digleds`        bclr PTJ, $02
22f7 72 10 1f                           inc CONT_TICKS
                        
                        
22fa                    returnOC4`      
22fa 0b                                 rti
                        
                        
                        
                        
                        
                        ;   Subrutina ATD
                        
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Subrutina utilizada para la conversion analogica digital del potenciometro de la tarjeta dragon 12, utilizado para
                        ;       controlar el brillo de los leds y las pantallas de 7 segmentos. Se toman 6 mediciones y se calcula el promedio.
                        
                        
                        ;Paso de parametros:
                        ;Entrada:
                                ;ADR00H,ADR01H,ADR02H,ADR03H,ADR04H,ADR05H: Registros de datos del convertidor analogico digital        
                        ;Salida:
                                ;Brillo: variable correspondiente a k en el ciclo de trabajo del control de los leds 
                                ;DT: Duty time, variable que determina cuanto tiempo deben permancer los leds encendidos.
                        ;################################################################################################################################################
                        ATD_ISR:        loc
22fb ce 00 06                           ldx #6
22fe dc 90                              ldd ADR00H
2300 d3 92                              addd ADR01H 
2302 d3 94                              addd ADR02H
2304 d3 96                              addd ADR03H     ;Se calcula el promedio de las 6 medidas del potenciometro
2306 d3 98                              addd ADR04H
2308 d3 9a                              addd ADR05H
230a 18 10                              idiv 
230c b7 54                              tfr X,D
230e 7b 10 0c                           stab POT      ;Guardar el promedio
2311 86 14                              ldaa #20
2313 12                                 mul
2314 ce 00 ff                           ldx #255
2317 18 10                              idiv
2319 b7 54                              tfr X,D
231b 7b 10 0b                           stab BRILLO
231e 86 05                              ldaa #5      ;Se multiplica por 5 para volverlo en escala a 100
2320 12                                 mul
2321 7b 10 20                           stab DT
                                        
                                        
2324 0b                                 rti
                        ;   Subrutina TCNT
                        
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Interrupcion causada por el overflow del contador de tiempo, esta encargada de incrementar el valor de los ticks que se usan para medir 
                        ;       la velocidad del vehiculo, así como el decremento de las variables que determinan el tiempo que se muestran las velocidades en la pantalla
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;Salida:
                                ;TICK_VEL: Ticks para medir la velocidad, solo si incrementan cuando se encuentra entre los dos sensores
                                ;TICK_EN: Ticks necesarios para mostrar la velocidad el medidor, se decrementan
                                ;TICK_DIS: Ticks necesarios para eliminar la velocidad el medidor, se decrementan
                        ;################################################################################################################################################
                                        loc
2325 dc 44              TCNT_ISR:       ldd TCNT
2327 18 0b ff 00 4f                     movb #$FF,TFLG2 ;                
232c b6 10 12                           ldaa TICK_VEL               
232f 81 ff                              cmpa #255                   ; si esta en valor maximo se mantiene ahi, esto resulta en una velocidad invalida
2331 27 08                              beq next1`
2333 1f 10 00 08 03                     brclr BANDERAS,$08,next1`      ;Revisa la bandera que habilita el conteo de ticks
2338 72 10 12                           inc TICK_VEL
233b f7 10 11           next1`          tst VELOC
233e 27 1a                              beq returnTCNT`
2340 fe 10 0d                           ldx TICK_EN                 ;Se comprueba que ticks enable sea diferente de 0
2343 09                                 dex
2344 26 04                              bne storeX1`
                                        ;movw #$FFFF,TICK_EN        ;Esta linea no es necesaria debido a que al restarle 1 se vuelve $FFFF
2346 1c 10 01 08                        bset (BANDERAS+1),$08          ;Banderas1.3 corresponde a pant_flag                    
234a 7e 10 0d           storeX1`        stx TICK_EN
234d fe 10 0f                           ldx TICK_DIS                ;Se comprueba que ticks disable sea diferente de 0
2350 09                                 dex                                              
2351 26 04                              bne storeX2`
                                        ;movw #$FFFF,TICK_DIS
2353 1d 10 01 08                        bclr (BANDERAS+1),$08 
2357 7e 10 0f           storeX2`        stx TICK_DIS
235a 0b                 returnTCNT`     rti
                        ;################################################################################################################################################
                        ;################################################################################################################################################
                        ;################################################################################################################################################
                        ;################################################################################################################################################
                        
                        ;       Subrutinas Generales
                        
                        
                        ;       Subrutina Tarea Teclado
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Subrutina encargada de manejar el teclado matricial de la tarjeta, suprime rebotes.
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       TECLA:  Tecla presionada en el teclado
                        ;       TECLA_IN:   Tecla presionada antes de suprimir los rebotes, se debe verificar que sea igual a TECLA
                        ;Salida:
                        ;################################################################################################################################################
                        
                        TAREA_TECLADO:  loc
235b f7 10 06                           tst CONT_REB
235e 26 47                              bne return`
2360 16 23 a8                           jsr MUX_TECLADO
2363 b6 10 04                           ldaa TECLA
2366 81 ff                              cmpa #$FF
2368 27 31                              beq checkLista`
236a 1e 10 01 02 11                     brset (BANDERAS+1),$02,checkLeida`        ;revision de bandera Tecla leida
236f 18 0c 10 04 10 05                  movb TECLA,TECLA_IN
2375 1c 10 01 02                        bset (BANDERAS+1),$02
2379 18 0b 0a 10 06                     movb #10,CONT_REB                       ;iniciar contador de rebotes
237e 20 27                              bra return`
2380 b1 10 05           checkLeida`     cmpa TECLA_IN                           ;Comparar Tecla con tecla_in
2383 26 06                              bne Diferente`
2385 1c 10 01 01                        bset (BANDERAS+1),$01
2389 20 1c                              bra return`
238b 18 0b ff 10 04     Diferente`      movb #$FF,TECLA                         ;Las teclas son invalidas
2390 18 0b ff 10 05                     movb #$FF,TECLA_IN
2395 1d 10 01 03                        bclr (BANDERAS+1),$03
2399 20 0c                              bra return`
239b 1f 10 01 01 07     checkLista`     brclr (BANDERAS+1),$01,return`              ;el numero esta listo
23a0 1d 10 01 03                        bclr (BANDERAS+1),$03
23a4 16 24 11                           jsr FORMAR_ARRAY
23a7 3d                 return`         rts
                        
                        
                        
                        ;       Subrutina MUX_TECLADO
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Subrutina encargada de capturar el valor presionado en el teclado matricial, para esto se envian un patron al puerto A, y se detecta
                        ;       la señal de entrada correspondiente, para esto se tiene una tabla de valores correspondientes a cada tecla.
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       TECLAS: Tabla que incluye los valores de cada una de las teclas del teclado
                        ;Salida:
                        ;       TECLA: Valor de la tecla presionada.
                        ;################################################################################################################################################
                        MUX_TECLADO:    loc
23a8 c6 00                              ldab #0
23aa 79 10 08                           clr PATRON
23ad ce 10 30                           ldx #TECLAS
23b0 f7 10 08           mainloop`       tst PATRON
23b3 26 07                              bne p1
23b5 18 0b ef 00 00                     movb #$EF,PORTA
23ba 20 26                              bra READ
23bc 86 01              p1:             ldaa #1
23be b1 10 08                           cmpa PATRON
23c1 26 07                              bne p2
23c3 18 0b df 00 00                     movb #$DF,PORTA
23c8 20 18                              bra READ
23ca 42                 p2:             inca                    ;A=2
23cb b1 10 08                           cmpa PATRON
23ce 26 07                              bne p3
23d0 18 0b bf 00 00                     movb #$BF,PORTA
23d5 20 0b                              bra READ
23d7 42                 p3:             inca                    ;A=3
23d8 b1 10 08                           cmpa PATRON             ;Se detecta cual patron se debe usar en la salida
23db 26 27                              bne nk
23dd 18 0b 7f 00 00                     movb #$7F,PORTA
23e2 a7                 read:           nop
23e3 a7                                 nop
23e4 a7                                 nop
23e5 a7                                 nop
23e6 a7                                 nop
23e7 a7                                 nop
23e8 a7                                 nop
23e9 a7                                 nop
23ea a7                                 nop
23eb a7                                 nop
23ec a7                                 nop
23ed a7                                 nop
23ee a7                                 nop
23ef a7                                 nop                     ;corrige problema de primera fila
23f0 4f 00 01 17                        brclr PORTA,$01, treturn`       ;se leen las entradas para encontrar la tecla presionada
23f4 52                                 incb
23f5 4f 00 02 12                        brclr PORTA,$02, treturn`
23f9 52                                 incb
23fa 4f 00 04 0d                        brclr PORTA,$04, treturn`
23fe 52                                 incb
23ff 72 10 08                           inc PATRON
2402 20 ac                              bra mainloop`
2404 18 0b ff 10 04     nk              movb #$FF,TECLA                 ;Se guarda la tecla o se retorna FF
2409 20 05                              bra return`
240b 18 0d e5 10 04     treturn`        movb B,X,TECLA
2410 3d                 return`         rts
                        ;       Subrutina formar array
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Esta subrutina es la encargada de almacenar los valores del teclado en memoria, para esto los valores de TECLA_in y TECLA deben ser iguales
                        ;       se tiene una cantidad maxima de teclas determinada por MAX_TCL, ademas al precionar la tecla enter no se pueden introducir más teclas,
                        ;       también al presionar la tecla B se puede eliminar un valor de memoria.
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       MAX_TCL: Cantidad maxima de teclas en el arreglo
                        ;       TECLA_IN: Valor de la tecla presionada.
                        ;       CONT_TCL: Puntero a la tecla actual
                        ;Salida:
                        ;       NUM_ARRAY: Arreglo donde se almacenan los valores en memoria.
                        ;################################################################################################################################################
                        
                        FORMAR_ARRAY:   loc
2411 ce 10 09                           ldx #NUM_ARRAY
2414 b6 10 05                           ldaa TECLA_IN
2417 f6 10 07                           ldab CONT_TCL
241a 27 0f                              beq check_MAX`
241c 81 0e                              cmpa #$0E
241e 27 1b                              beq t_enter`
2420 81 0b                              cmpa #$0B
2422 27 22                              beq t_borrar`
2424 f1 10 03                           cmpb MAX_TCL
2427 27 25                              beq return`
2429 20 08                              bra guardar`
242b 81 0e              check_MAX`      cmpa #$0E
242d 27 1f                              beq return`
242f 81 0b                              cmpa #$0B
2431 27 1b                              beq return`
2433 6a e5              guardar`        staa B,X
2435 52                                 incb
2436 7b 10 07                           stab CONT_TCL
2439 20 13                              bra return`
243b 1c 10 01 04        t_enter`        bset (BANDERAS+1),$04
243f 18 0b 00 10 07                     movb #$0,CONT_TCL
2444 20 08                              bra return`
2446 53                 t_borrar`       decb
2447 18 08 e5 ff                        movb #$FF,B,X
244b 7b 10 07                           stab CONT_TCL
244e 3d                 return`         rts
                        
                        
                        
                        
                        ;       BCD_7SEG
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Subrutina encargada convertir valores en formato BCD a los valores necesarios para poder visualizarlos en la pantalla de 7 segmentos.
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       BC1,BCD2: Valores en bcd a convertir
                        ;       SEGMENT: Tabla que contiene los valores para cada uno de los digitos.
                        ;Salida:
                        ;       DISP1,DISP2,DISP3,DISP4: Valores en 7 segmentos para cada uno de los displays
                        ;################################################################################################################################################
                        BCD_7SEG:       loc
244f ce 10 40                           ldx #SEGMENT
2452 cd 10 19                           ldy #DISP1
2455 86 00                              ldaa #0
2457 f6 10 15                           ldab BCD1
245a 20 03                              bra subrutinabcd`
245c f6 10 16           loadBCD2`       ldab BCD2
245f 37                 subrutinabcd`   pshb 
2460 c4 0f                              andb #$0F
2462 18 0a e5 70                        movb B,X,1,Y+      ;muevo la parte baja de bcd a disp2 o disp 4
2466 33                                 pulb 
2467 54                                 lsrb
2468 54                                 lsrb
2469 54                                 lsrb
246a 54                                 lsrb
246b 18 0a e5 70                        movb B,X,1,Y+     ;muevo la parte alta de bcd a disp 1 o disp4
246f 8d 10 1b                           cpy #DISP3
2472 27 e8                              beq loadBCD2`
2474 3d                 returnBCD_7SEG: rts
                        
                        
                        ;       CARGAR_LCD
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;           Subrutina encargada de enviar la información a desplegar en la pantalla LCD
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       ;iniDsp: Tabla de comandos para iniciar la comunicación con la pantalla
                        ;       ADD_L1,ADD_L2: Comandos para añadir lineas
                        ;       Registro X: Contiene el puntero para el contenido de la linea 1
                        ;       Registro Y: Contiene el puntero para el contenido de la linea 2           
                        ;       D60us,D2ms: Constantes para el tiempo de espera necesario para la comunicación correcta con la pantalla.
                        ;Salida:
                        ;################################################################################################################################################
                        CARGAR_LCD:     loc                
2475 34                                 pshx
2476 ce 10 50                           ldx #iniDsp
2479 e6 30                              ldab 1,X+
247b a6 30              loop1`          ldaa 1,X+
247d 1d 10 00 02                        bclr BANDERAS,$02
2481 16 24 fb                           jsr Send
2484 18 0c 10 28 10 25                  movb D60uS,CONT_DELAY
248a 16 25 42                           jsr Delay
248d 04 31 eb                           dbne B,loop1`           ;hasta aqui se estan mandando los comando iniciales de dsp
2490 1d 10 00 02                        bclr BANDERAS,$02
2494 b6 10 29                           ldaa Clear_LCD
2497 16 24 fb                           jsr Send                ;hasta aqui se borra la pantalla
249a 18 0c 10 26 10 25                  movb D2mS,CONT_DELAY
24a0 16 25 42                           jsr Delay
24a3 30                                 pulx
24a4 b6 10 2a                           ldaa ADD_L1                        ;aqui empieza cargar lcd
24a7 1d 10 00 02                        bclr BANDERAS,$02
24ab 16 24 fb                           jsr Send
24ae 18 0c 10 28 10 25                  movb D60uS,CONT_DELAY
24b4 16 25 42                           jsr Delay
24b7 a6 30              loop2`          ldaa 1,X+
24b9 81 00                              cmpa #FIN
24bb 27 12                              beq linea2`
24bd 1c 10 00 02                        bset BANDERAS,$02
24c1 16 24 fb                           jsr Send
24c4 18 0c 10 28 10 25                  movb D60uS,CONT_DELAY
24ca 16 25 42                           jsr Delay
24cd 20 e8                              bra loop2`
24cf b6 10 2b           linea2`         ldaa ADD_L2                        ;aqui empieza cargar la linea 2
24d2 1d 10 00 02                        bclr BANDERAS,$02
24d6 16 24 fb                           jsr Send
24d9 18 0c 10 28 10 25                  movb D60uS,CONT_DELAY
24df 16 25 42                           jsr Delay
24e2 a6 70              loop3`          ldaa 1,Y+
24e4 81 00                              cmpa #FIN
24e6 27 12                              beq returnLCD`
24e8 1c 10 00 02                        bset BANDERAS,$02
24ec 16 24 fb                           jsr Send
24ef 18 0c 10 28 10 25                  movb D60uS,CONT_DELAY
24f5 16 25 42                           jsr Delay
24f8 20 e8                              bra loop3`
24fa 3d                 returnLCD`      rts
                        
                        
                        ;       Send
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Subrutina encarga de enviar los datos o comando a la pantalla LCD
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       Banderas.1: Indica si es un comando o datos
                        ;       Registro: Contenido del comando o dato a enviar a la pantalla
                        ;       D240us: Constante con el valor necesario para generar el delay
                        ;Salida:
                        ;################################################################################################################################################
                                        loc
24fb 36                 Send:           psha
24fc 84 f0                              anda #$F0               ;Inicialmente se debe mandar la parte alta 
24fe 44                                 lsra                    ;desplazamiento necesario
24ff 44                                 lsra
2500 5a 32                              staa PORTK
2502 1e 10 00 02 05                     brset BANDERAS,$02,dato1`          ;Se revisa la bandera para determinar si es un dato o si es un comando
2507 4d 32 01                           bclr PORTK,$01          
250a 20 03                              bra continue1`
250c 4c 32 01           dato1`          bset PORTK,$01
250f 4c 32 02           continue1`      bset PORTK,$02
2512 18 0c 10 27 10 25                  movb D240uS,CONT_DELAY          ;Se genera el retraso correspondiente
2518 16 25 42                           jsr Delay
251b 4d 32 02                           bclr PORTK,$02
251e 32                                 pula
251f 84 0f                              anda #$0F               ;Cuando se completa la transferencia de la parte alta se envia la parte baja del dato
2521 48                                 lsla
2522 48                                 lsla
2523 5a 32                              staa PORTK
2525 1e 10 00 02 05                     brset BANDERAS,$02,dato2`
252a 4d 32 01                           bclr PORTK,$01
252d 20 03                              bra continue2`
252f 4c 32 01           dato2`          bset PORTK,$01
2532 4c 32 02           continue2`      bset PORTK,$02
2535 18 0c 10 27 10 25                  movb D240uS,CONT_DELAY
253b 16 25 42                           jsr Delay
253e 4d 32 02                           bclr PORTK,$02
2541 3d                                 rts    
                        
                        ;       Delay
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Subrutina de retraso, solo debe consumir el tiempo necesario para la comunicacion con la pantalla.               
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       CONT_DELAY: Contador que indica que tanto se debe esperar.
                        ;Salida:
                        ;################################################################################################################################################
                                        loc
2542 f7 10 25           Delay:          tst CONT_DELAY 
2545 26 fb                              bne Delay
2547 3d                                 rts
                        
                        ;       CONV_BIN_BCD
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Subrutina de llamado a conversion Binaria a BCD, determina si el valor se en binario se puede convertir o si es el correspondiente
                        ;       a apagar la pantalla o mostrar guines.
                        
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       BIN1,BIN2: Valores a convertir
                        ;Salida:
                        ;       BCD1,BCD2: Valores convertidos.
                        ;################################################################################################################################################
                                        loc
2548 b6 10 13           CONV_BIN_BCD:   ldaa BIN1
254b 81 bb                              cmpa #$BB
254d 26 07                              bne cont1`
254f 18 0b bb 10 15                     movb #$BB,BCD1
2554 20 14                              bra next`
2556 81 aa              cont1`          cmpa #$AA
2558 26 07                              bne cont2`
255a 18 0b aa 10 15                     movb #$AA,BCD1
255f 20 09                              bra next`
2561 16 25 8d           cont2`          jsr BIN_BCD
2564 18 0c 10 17 10 15                  movb BCD_L,BCD1
256a b6 10 14           next`           ldaa BIN2
256d 81 bb                              cmpa #$BB
256f 26 07                              bne cont3`
2571 18 0b bb 10 16                     movb #$BB,BCD2
2576 20 14                              bra return`
2578 81 aa              cont3`          cmpa #$AA
257a 26 07                              bne cont4`
257c 18 0b aa 10 16                     movb #$AA,BCD2
2581 20 09                              bra return`
2583 16 25 8d           cont4`          jsr BIN_BCD
2586 18 0c 10 17 10 16                  movb BCD_L,BCD2                                
258c 3d                 return`         rts
                        
                        ;       BIN_BCD
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Conversion de 1 valor en binario de 8 bits a BCD
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       Registro A: En este registro se encuentra el contenido a convertir
                        ;Salida: 
                        ;       BCD_L: Posicion de memoria donde se retorna el resultado en BCD        
                        ;################################################################################################################################################
                                        loc
258d c6 07              BIN_BCD:        ldab #7
258f 79 10 17                           clr BCD_L
2592 ce 10 17                           ldx #BCD_L        
2595 48                 loop`           lsla
2596 65 00                              rol 0,X
2598 7a 10 2c                           staa TEMP
259b a6 00                              ldaa 0,X
259d 84 0f                              anda #$0F
259f 81 05                              cmpa #5
25a1 2d 02                              blt continue1`
25a3 8b 03                              adda #3
25a5 7a 10 18           continue1`      staa LOW 
25a8 a6 00                              ldaa 0,X
25aa 84 f0                              anda #$F0
25ac 81 50                              cmpa #$50
25ae 2d 02                              blt continue2`
25b0 8b 30                              adda #$30
25b2 bb 10 18           continue2`      adda LOW
25b5 6a 00                              staa 0,X
25b7 b6 10 2c                           ldaa TEMP
25ba 53                                 decb
25bb c1 00                              cmpb #$0 
25bd 26 d6                              bne loop`
25bf 48                                 lsla
25c0 65 00                              rol 0,X                           
25c2 3d                                 rts
                        
                        ;       BCD_BIN
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Conversion de BCD a binario, utilizada para convertir el valor del arreglo del teclado a un valor numerico.
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       NUM_ARRAY: Arreglo de numero en bcd producidos por el teclado.
                        ;Salida:
                        ;       V_LIM: Valor en binario resultante de la conversion, corresponde a la velocidad limite.    
                        ;################################################################################################################################################
                                        loc
25c3 ce 10 09           BCD_BIN:        ldx #NUM_ARRAY
25c6 a6 01                              ldaa 1,X
25c8 81 ff                              cmpa #$FF       ;verifica que el segundo numero no sea FF
25ca 27 22                              beq wrong`
25cc 86 00                              ldaa #0
25ce 81 00              loop`           cmpa #0
25d0 27 04                              beq mul10`;
25d2 eb e4                              addb A,X    
25d4 20 09                              bra sumarA`
25d6 e6 e4              mul10`          ldab A,X
25d8 58                                 lslb
25d9 58                                 lslb
25da 58                                 lslb        ;mult por 8
25db eb e4                              addb A,X
25dd eb e4                              addb A,X    ;mult por 10
25df 18 08 e4 ff        sumarA`         movb #$FF,A,X
25e3 42                                 inca
25e4 b1 10 03                           cmpa MAX_TCL
25e7 26 e5                              bne loop`
25e9 7b 10 02                           stab V_LIM 
25ec 20 0a                              bra return`
25ee 18 0b ff 10 09     wrong`          movb #$FF,NUM_ARRAY
25f3 18 0b 00 10 02                     movb #$0,V_LIM
25f8 3d                 return`         rts
                        
                        ;       MODO_CONFIG
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Modo de operación del sensor de velocidad, en este modo se configura la velocidad limite del sensor. Para esto se debe verificar que 
                        ;       el valor ingresado en el teclado sea valido es decir entre el rango de 45 y 90 km/h, si no es valido se borra el valor ingresado, si 
                        ;       sí es valido se muestra en pantalla y se mantiene en memoria.
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       V_LIM: Velocidad limite ingresada.
                        ;Salida:
                        ;       BIN1: Valor en binario que se debe mostrar en los displays de 7 segmentos 1 y 2
                        ;       BIN2: Valor en binario que se debe mostrar en los displays de 7 segmentos 3 y 4, en este caso BB para que se apaguen
                        ;################################################################################################################################################
                        MODO_CONFIG:    loc
                                        
25f9 1f 10 01 04 1f                     brclr (BANDERAS+1),$04,jtarea_teclado`     ;Se revisa array ok
25fe 16 25 c3                           jsr BCD_BIN
2601 1d 10 01 04                        bclr (BANDERAS+1),$04
2605 b6 10 02                           ldaa V_LIM
2608 81 5a                              cmpa #90
260a 2e 16                              bgt resetV_LIM`
260c 81 2d                              cmpa #45
260e 2d 12                              blt resetV_LIM`
2610 18 0c 10 02 10 13                  movb V_LIM,BIN1
2616 18 0b bb 10 14                     movb #$BB,BIN2
261b 20 08                              bra returnCofig
261d 16 23 5b           jtarea_teclado` jsr TAREA_TECLADO
2620 20 03                              bra returnCofig
2622 79 10 02           resetV_LIM`     clr V_LIM
2625 3d                 returnCofig:    rts
                        
                        ;       MODO_MEDICION
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Modo de operación del sensor de velocidad, determinar si la velocidad es mayor a 0, si los es llama a la subrutina de control de la 
                        ;       pantalla, además cuando el vehiculo pasa por el primer sensor muestra el mensaje "Calculando" en pantalla.
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       BANDERAS.4: Bandera que indica cuando imprimir el mensaje.
                        ;       VELOC: Velocidad actual del vehiculo.
                        ;Salida:
                        ;################################################################################################################################################
                        MODO_MEDICION:  loc
2626 f7 10 11                           tst VELOC
2629 27 05                              beq tstflg`
262b 16 26 52                           jsr PANT_CTRL                       ;Si la velocidad es mayor a 0 se modifican las pantallas
262e 20 16                              bra returnMM`
2630 1f 10 00 04 11     tstflg`         brclr BANDERAS,$04,returnMM`       ;Si la bandera de imprimir Calculando está activa se imprime el mensaje
2635 1d 02 66 08                        bclr PIEH,$08
2639 ce 10 99                           ldx #MESS5
263c cd 10 c7                           ldy #MESS8  
263f 16 24 75                           jsr CARGAR_LCD
2642 1d 10 00 04                        bclr BANDERAS,$04                  ;Se borra la bandera de imprimir Calculando        
2646 3d                 returnMM`       rts
                        
                        ;       MODO_LIBRE
                        ;################################################################################################################################################
                        ;Descripcion:
                                ;Modo de operación del sensor, este es un modo donde no se realiza ninguna operación, solo se borran los valores desplegados en las
                                ;pantallas de 7 segmentos.
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;Salida:
                        ;       BIN1,BIN2: Se debe borrar la pantalla de 7seg, para esto se envia BB a estas posiciones de memoria.
                        ;################################################################################################################################################
                        MODO_LIBRE:     loc                
2647 18 0b bb 10 13                     movb #$BB,BIN1
264c 18 0b bb 10 14                     movb #$BB,BIN2
2651 3d                                 rts
                        
                        ;       PANT_CTRL
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Subrutina encargada de manipular las pantallas cuando se detecta el paso de un vehiculo, si la velocidad se sale de los limites que se 
                        ;       pueden leer se muestran guiones acompañados de la velocidad limite, si es un valor valido pero mayor que la velocidad limite se activa 
                        ;       una alarma en los leds, luego se muestra la velocidad cuando el vehiculo pasa 100 m después del segundo sensor, lo mismo ocurre para una
                        ;       velocidad adentro del limite pero no se activa la alarma de los leds.
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       VELOC: Velocidad del vehiculo
                        ;       V_LIM: Velocidad limite, configurada en modo config
                        ;Salida:
                        ;       BIN1: Se configura segun la velocidad del vehiculo, se apaga (BB) cuando ya el vehiculo pasa el sensor
                        ;       BIN2: Se envia el valor de la velocidad limite, se apaga (BB) cuando ya el vehiculo pasa el sensor
                        ;       (BANDERAS+1).4: Bandera de alarma.
                        ;################################################################################################################################################                
                        
                                        loc
2652 1d 02 66 09        PANT_CTRL:      bclr PIEH,$09
2656 1c 02 67 09                        bset PIFH,$09
265a b6 10 11                           ldaa VELOC
265d 81 1e                              cmpa #30                ;Se verifica que la velocidad este adentro del rango 30-99
265f 2d 0f                              blt outOfBounds`
2661 81 63                              cmpa #99
2663 2e 0b                              bgt outOfBounds`
2665 b1 10 02                           cmpa V_LIM
2668 2f 1b                              ble next`
266a 1c 10 01 10                        bset (BANDERAS+1),$10      ;Levantar Alerta si es mayor a la velocidad limite
266e 20 15                              bra next`
2670 81 aa              outOfBounds`    cmpa #$AA
2672 27 11                              beq next`
2674 18 03 00 01 10 0d                  movw #1,TICK_EN
267a 18 03 00 5c 10 0f                  movw #92,TICK_DIS
2680 18 0b aa 10 11                     movb #$AA,VELOC                            
2685 1e 10 01 08 2b     next`           brset (BANDERAS+1),$08,loadSpeed`  ;Se revisa PANT_FLAG si esta en 1 se carga en pantalla la velocidad y el mensaje correspondiente
268a b6 10 13                           ldaa BIN1               ;En esta rama se decide si enviar el mensaje de espera y devolver las variables a 0
268d 81 bb                              cmpa #$BB               ;Si el valor de bin1 es diferente de #$BB es porque todavía no se ha enviado el mensaje
268f 27 40                              beq returnPC`
                                        
2691 ce 10 99                           ldx #MESS5
2694 cd 10 b8                           ldy #MESS7
2697 16 24 75                           jsr CARGAR_LCD          ;Se enviar MODO_Medicion y esperando...
269a 18 0b bb 10 13                     movb #$BB,BIN1
269f 18 0b bb 10 14                     movb #$BB,BIN2
26a4 79 10 11                           clr VELOC
26a7 1d 10 01 10                        bclr (BANDERAS+1),$10      ;Borrar Alerta 
26ab 1c 02 67 09                        bset PIFH,$09
26af 1c 02 66 09                        bset PIEH,$09
                                        
                        
26b3 20 1c                              bra returnPC`
26b5 b6 10 13           loadSpeed`      ldaa BIN1               ;Se decide si enviar el mensaje con las velocidades
26b8 81 bb                              cmpa #$BB               ;Si el valor es #$BB no se ha enviado el mensaje
26ba 26 15                              bne returnPC`
26bc 18 0c 10 02 10 13                  movb V_LIM,BIN1
26c2 18 0c 10 11 10 14                  movb VELOC,BIN2
26c8 ce 10 99                           ldx #MESS5
26cb cd 10 a8                           ldy #MESS6
26ce 16 24 75                           jsr CARGAR_LCD          ;Se enviar MODO_Medicion y su.vel y vel limite
                        
26d1 3d                 returnPC`       rts
                        
                        
                        
                        
                        
                        ;       PATRON_LEDS
                        ;################################################################################################################################################
                        ;Descripcion:
                        ;       Controla lo que se muestra en los leds en el modo medicion, si la alarma esta activada se encienden en forma secuencial los leds de 3 a 7
                        
                        ;Paso de parametros:
                        ;Entrada:
                        ;       (BANDERAS+1).4: Bandera de alarma.
                        ;Salida:
                        ;       LEDS: Variable que controla el patron de los leds
                        ;################################################################################################################################################                
                                        loc
26d2 1e 10 01 10 06     PATRON_LEDS:    brset (BANDERAS+1),$10,activateAl`         ;Se revisa si la alarma está activada
26d7 1d 10 1d f8                        bclr LEDS,$F8
26db 20 19                              bra returnPL`
26dd 86 08              activateAl`     ldaa #$08
26df b1 10 2d                           cmpa LEDS37                 ;Se revisa que no este en el ultimo led
26e2 27 05                              beq resLEDS37`
26e4 74 10 2d                           lsr LEDS37          ;Si no esta en el ultimo led se realiza un desplazamiento
26e7 20 05                              bra chLEDS`
26e9 18 0b 80 10 2d     resLEDS37`      movb #$80,LEDS37        ;Si es igual se devuelve al primer led
26ee b6 10 2d           chLEDS`         ldaa LEDS37
26f1 8b 02                              adda #2             ;Se le suma 2 para encender el led de modo medicion
26f3 7a 10 1d                           staa LEDS                   
26f6 3d                 returnPL`       rts                             

Executed: Wed Dec 04 23:56:36 2019
Total cycles: 2013, Total bytes: 1948
Total errors: 0, Total warnings: 0
